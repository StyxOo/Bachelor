\chapter{Implementation}\label{sec:implementation}
%\textcolor{red}{

%How are the chosen diagrams implemented? Which D3 modules have been used? How was the implementation done?}

In the following sections the process of creating the diagrams and the showcase are described. Understanding the implementations of the diagrams is important to be able to evaluate the possibilities, as well as the advantages and disadvantages of working with D3.
There are several parts to the process of creating the diagrams and the showcase. At first the data sets to be represented are selected. In most real world usages, this is already given when having to create data visualizations. Afterwards, section \ref{sec:diagram-selection}lists not only the implemented diagrams, but also why they have been selected. In section \ref{sec:data-acquisition} and following, their implementation and usage of D3 is described. Finally, in section \ref{sec:showcase}, the showcase, as well as how data updates are realized, are described.

The implementation uses the currently latest version of D3, version 7.6.1. The JavaScript code uses exclusively arrow functions which have been introduced in ECMAScript6, the specification which JavaScript is build upon\cite{ecmascript}. The implementations live version at "\url{https://styxoo.github.io/}" has been successfully tested using the following operating systems, browsers and versions:
\begin{enumerate}
    \item Windows 10:
    \begin{enumerate}
        \item Opera - version 90.0.4480.54
        \item Microsoft Edge - version 104.0.1293.70
    \end{enumerate}
    \item Pop!\_OS 22.04 LTS:
    \begin{enumerate}
        \item Firefox - version 103.0
        \item Chromium - version 104.0.5112.101
    \end{enumerate}
    \item MacOS 12.4:
    \begin{enumerate}
        \item Safari - version 15.5
    \end{enumerate}
\end{enumerate}

Besides the usual code comments, all the code files created for this thesis are commented to highlight and show the working and functionality of D3 and how it is used. As not every section of code is described in this chapter, the comments provide additional help to readers trying to understand the implementations of the diagrams. Furthermore it helps developers interested in adapting the diagrams implementations for their own use.

\section{Data sets}\label{sec:data-sets}
%\textcolor{red}{
%What are our datasets about? Where do they come from?}
This section introduces the data sets used in the creation of the diagrams of this thesis. Not only does this section provide an explanation why the specific data sets have been chosen, but also explains the preprocessing which has been done and how it was achieved.

As different data types allow for different representations and require varying parts of D3, the data used in this thesis has been specifically chosen to contain both types of categorical as well as numeric data. As there are no differences in the implementation of discrete and continuous data, only discrete data is used.

All data used for the creation of the diagrams in this thesis originates from the UNHCR Ukraine refugee situation page \cite{unhcr}. "UNHCR stands for United Nations High Commissioner for Refugees, also known as the UN Refugee Agency. It was created in 1950 to help millions of Europeans who had fled or lost their homes during the Second World War. Today, UNHCR protects and assists millions of displaced and stateless people around the world."\cite{unhcr_what}
This thesis makes use of three data sets. The first data set is about the total cumulative border crossings from Ukraine per day \cite{unhcr_rpd} and is in JSON format. The other two data set are about the border crossings into countries featured in the refugee response plan and about border crossings into other neighboring countries \cite{unhcr}. They were extracted directly as CSVs. While all data references border crossings from Ukraine and not refugees directly, the UNHCR states that "[they do] not count border crossings of individuals from bordering countries leaving Ukraine to return home (i.e. Romanians returning to Romania), nonetheless among those forced to flee Ukraine are also Ukrainian nationals with dual citizenship"\cite{unhcr_note}. Therefore this thesis will henceforth refer to the fleeing individuals that crossed the borders as refugees.
The refugees per country cover a time span between february 24th 2022 up until august 16th 2022\cite{unhcr}. The refugees per day cover the time from february 24th 2022 until july 17th 2022\cite{unhcr_rpd}.

As the situation in the Ukraine is still ongoing, it is hard to acquire accurate refugee data. This is also mentioned on the UNHCR situation page, were it is stated that "Statistics are compiled mainly from data provided by authorities. While every effort has been made to ensure that all statistical information is verified, figures represent an estimate. Triangulation of information and sources is performed on a continuous basis. Therefore, amendments to figures may occur, including retroactively."\cite{unhcr}.

%(Due to the currentness of the situation, the UNHCR only recently changed to using border crossings from Ukraine. Previously these were referred to as refugees fleeing Ukraine. As the implementation was already completed at this point and because it makes no difference to the workings of D3, this thesis will henceforth use the refugee wording again.)

To keep the implementations of the diagrams as simple as possible data preprocessing is done as the data is loaded from their respective files, to make it align with the internally used data structure. Therefore two data loader JavaScript files have been created. The first JavaScript file, the countryDataLoader.js reads both csv files containing information about the refugees crossing into neighboring countries. Both files are then combined to one data array containing an object, with properties for country and refugees, for each data entry. The second data loader, the dailyDataLoader.js, reads the JSON file containing information about the total refugees per day. This JSON file contains a lot of filler data repeating http request headers, timestamps in both unix and YYY-MM-DD format and a brief description of the Ukraine situation as well as the data. Therefore the data loader strips all unnecessarily information away and produces a single array. This array contains an object, with properties for date and refugees, for each data entry. A section of both of the resulting data arrays can be seen in table \ref{tab:data}. Both data loaders are accessed either by the respective data services which pass the data to the applicable diagrams, or by the diagrams directly. The data services, countryDataService.js and dailyDataService.js, are used by the showcase to fill the data tables in the showcase and pass along any manual data changes done in these tables to the applicable diagrams.

\begin{table}[ht]
    \centering
    \begin{tabular}{l|r}
        Country & Refugees \\
        \hline \hline
        Poland & 5439431 \\
        Russian Federation & 2197679 \\
        ... & ... \\
        Belarus & 16689 \\
    \end{tabular}
    \quad
    \begin{tabular}{l|r}
        Date & Refugees \\
        \hline \hline
        Feb 24, 2022 & 79209 \\
        Feb 25, 2022 & 179525 \\
        ... & ... \\
        Jul 19, 2022 & 9567033 \\
    \end{tabular}
    \captionsetup{width=0.9\textwidth}
    \caption{A preview of the two data arrays after preprocessing. The left table contains the refugees per country. The right table shows the cumulative refugees per day. Each entry in the table corresponds to one object in the appropriate data array. Each object has two properties, according to the headers of the tables. The dates in the right table are JavaScript date objects. They are shortened here for readability.}
    \label{tab:data}
\end{table}


Together both resulting data sets contain most of the data types. The number of refugees, which can be found in both data sets, is a discrete attribute. The countries in one data set are a nominal attribute. The date in the other data set is a ordinal attribute instead.



%It would be possible to use both these data sets as is. Yet the vast amounts of filler data, which does not contain any valuable information, makes data accesses unnecessarily complicated and hard to follow along and understand the diagrams implementations. Therefore both data sets are preprocessed. In both cases the data sets are read and the valuable information extracted and saved in the CSV format. Both of the newly created CSV files have two columns and one header row. The resulting CSV of the refugees per country dataset, contains the two columns of country and refugees. The other resulting CSV contains a column for the date and one for the cumulative refugees. 

%(The data set about the refugees per country can also easily be converted into using percentages. After adding up the total amount of refugees from each data point, one can convert the absolute number of refugees into percent.)

%\subsection{Data Types}
%\textcolor{red}{
%Which data types can be found in our data sets? Where?}

%The two chosen data sets already cover most of the data types. Both dataset contain two attributes per data point. The country is a categorical attribute. The number of refugees is discrete. When converting this data set into percentages, the percentage of refugees becomes a continuous attribute. In the refugees per date data set, the amount of refugees is still a discrete attribute. The date itself is an ordinal attribute though. As one day clearly comes before and after other days.

%Choosing data sets which cover all types of data types was an important consideration. Different data types can have different ways of representation, as well as different ways of implementation on the programming side of things.


\section{Diagrams}
%\textcolor{red}{
%describe all the diagrams and why they are special and what makes them tick. Why have they been chosen?}

The following sub-sections are about selecting and implementing each diagram. As there are countless ways to show the selected data sets, a selection of diagrams was made first. Afterwards the implementations common features are explained, before providing more details of the specific implementations of each diagram.

\subsection{Diagram selection} \label{sec:diagram-selection}
Two major aspects are taken into the account for selecting the diagrams. Primarily, they should all require different functionalities of the D3 library. This ensures that this thesis actually tests the broad possibilities of D3. To achieve this, four diagrams have been chosen to show the refugees per country data set. A bar chart, a donut chart, a tree map and a Sankey diagram. For the data set showing the total amount of refugees over time, a circle graph and an area graph have been chosen.
Secondly, the created diagrams should be realistically usable. This means that they should be usable by for example news agencies or on the UNHCR website, as there is no point in creating unnecessarily complex and unusable visualizations.

The bar chart was chosen for implementation due to its simplicity and minimal amount of D3 functions needed. As it mostly relies on simple \texttt{rect} and \texttt{text} SVG tags, it provides a good starting point for learning D3. Additionally, it is a frequently occurring diagram. Especially considering that column charts only differ in the orientation, but are functionally the same. The bar chart was chosen over a column chart, as the horizontal orientation of the bar chart allows the viewer to read the country name and the number of refugees in one line.
The main reason for choosing the donut chart was its use of the specific D3 functions for creating pie and donut charts. The donut chart was chosen over a pie chart for it's compact form while still allowing some additional information to be shown in the center. It is also used to present custom attribute tweens for animations.
The usage of D3s tree map functions was the main reason for choosing the tree map. Additionally it offers a good example for including CSS styling tricks, a tooltip and event-handling using D3.
Both the tree map and Sankey diagram also provide an insight into working with hierarchical data structures. The Sankey diagram was additionally chosen to present the usage of D3 plugins.
The circle graph was chosen to show more D3 scales, as well as the possibilities of using scales to create custom legends.
Lastly, the area graph uses more basic D3 functions for rendering lines and areas. These have not been used before, but can prove quite powerful when creating diagrams showing trends over time.

Whilst all diagrams are presented in one showcase, each diagrams is implemented to work standalone. This makes the comparison between diagrams, as well as evaluating the effort needed to create them easier. It also allows for easier adaptation if one were to use one of the diagrams as a template. Therefore all diagrams are implemented independently, using three parts: a HTML, a CSS and a JavaScript file. The HTML loads the D3 library and the applicable data loader in the header. This data loader is only used when the diagram is accessed directly. This can be done by clicking the diagram in the showcase. The body of the HTML consists of a SVG tag where the diagram will be drawn, and a script tag which loads the JavaScript file. The CSS defines the general styling of the diagram which is not dependent on the input data. The main part of the implementation is done in the Javascript section.

The JavaScript implementation follows a general pattern. At first there is a initialization section (\ref{sec:initialization}) which is run once as the diagram is loaded. It is followed by a render function (\ref{sec:render}) which is responsible for drawing and updating the diagram. As there is no point in drawing a diagram without data, the process of how the diagram is provided the data to show is described next.

\subsection{Data acquisition} \label{sec:data-acquisition}
Each diagram has two possible ways to acquire data. This is due to the fact that they are implemented to be shown in the showcase, but also work standalone. Each diagram will first check if there is a data service available. This is true if the diagram is loaded in the showcase. If a data service is available, the diagram will register itself with the data service for data and data updates (Figure \ref{fig:showcase-flowchart}). Otherwise the diagram will access the data loader directly (Figure \ref{fig:diagram-flowchart}). This will only provide data once, as the diagram is loaded.

\begin{figure}[ht]
    \includegraphics[width=\linewidth]{showcase-flow.png}
    \captionsetup{width=0.9\textwidth}
    \caption[showcase-flowchart]{This flowchart describes the behavior when loading the showcase and when data is updated. As registering with the data service and loading the data happens simultaneously, the data service returns the latest available data to the diagram when it registers for data updates. This prevents issues which might occur due to timing.}
    \label{fig:showcase-flowchart}
\end{figure}

\begin{figure}[ht]
    \includegraphics[width=\linewidth]{diagram-flow.png}
    \captionsetup{width=0.9\textwidth}
    \caption[diagram-flowchart]{This flowchart describes the behavior when loading a diagram directly. As the diagram is unable to register with a data service, it will request the data directly from the data loader.}
    \label{fig:diagram-flowchart}
\end{figure}

\subsection{Initialization}\label{sec:initialization}
All things which are independent of the data are done during the initialization of a diagram. It starts with setting some core variables. A reference to the SVG tag, which will be used as the container for the diagram, is made. It is followed by a margin definition for all four sides, where the margin of our diagram content in relation to the container size is defined. The resulting values for \verb|contentHeight| and \verb|contentWidth|, which are used as space to draw the diagram, are saved. 

Afterwards, there are a few SVG group elements added to the SVG container. Adding elements is achieved by calling \verb|.append('elementName')| on an existing element. In the first case, this element is the previously stored reference to the SVG container. As the \verb|append| command returns the newly created element, it can be directly stored in a variable for later reference. It can also be provided with attributes and styles via method chaining. The group elements added here provide a general hierarchy for different aspects of the diagram. Listing \ref{lst:hierarchy_creation} demonstrates how this works for the bar chart. Having a proper structure in place makes working with selections easier, helps with human readability of the SVGs content and makes debugging using the browsers inspector faster. As SVG elements are drawn on top of each other depending on their hierarchical order, this can also be used to mimic layers as they would be used in drawing applications. This general hierarchy is only created to a level which is independent of the provided data and differs depending on the type of diagram. For example the bar chart has separate groups for the axes and the content, see listing \ref{lst:hierarchy_result}, while the circle diagram has groups for the background legend and the content.

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={JavaScript code to create the hierarchy as used in the bar chart. The first line adds a new group element to the main SVG container using the \texttt{append} command. The newly added group element is saved in a constant for later references. Furthermore in line two an attribute is added to the new group element using the \texttt{attr} command and method chaining. It moves the group element from the left and top to allign with the margin definition. In each of the lines four, seven and ten, another group element is added. They are added to the previously created group element. They are all stored in constants for later reference and are provided with ID's for easier identification and debugging.}, label={lst:hierarchy_creation}]
const diagramGroup = SVG.append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

const xAxisParentGroup = diagramGroup.append('g')
    .attr('id', 'xAxis')

const yAxisParentGroup = diagramGroup.append('g')
    .attr('id', 'yAxis')

const contentParentGroup = diagramGroup.append('g')
    .attr('id', 'content')
\end{lstlisting}
\end{minipage}

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={The HTML structure which results from the JavaScript code in listing \ref{lst:hierarchy_creation}. The resulting tree structure clearly separates the different aspects of the diagram. Using a hierarchical approach makes not only later selections easier, but also increases human readability and simplifies debugging.}, label={lst:hierarchy_result}]
<SVG>
    <g transform=translate(118,20)>
        <g id="xAxis"></g>
        <g id="yAxis"></g>
        <g id="content"></g>
    </g>
</SVG>
    \end{lstlisting}
\end{minipage}

If there are data independent scales, they are defined next. A common example here is a color scale for nominal values. It is used in all diagrams showing the refugees per country. When queried, it will return a new color from the provided range for each new query value. This scale does not require a predefined domain. Instead it is dynamically defined and extended with each new value querying the scale. It is important to note that when the predefined color list runs out of new colors, it starts reusing the same color list from the beginning.

\begin{minipage}{0.9\linewidth}
    \begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={Definition of the data independent color scale. \texttt{d3.schemeDarkv2} is a predefined list of color values which is  used as the range of the scale.}, label={color_scale}]
const colors = d3.scaleOrdinal(d3.schemeDark2);
    \end{lstlisting}
\end{minipage}

If there are any static elements, they are also defined in the initialization. For example the tooltip used by the tree map or the center text fields in the donut chart. Even though the data which these fields are supposed to show is not yet known, these fields are persistent and can therefore already be created here.

Finally any general helper functions are also defined here. Both diagrams about the cumulative refugees per day make use of a date conversion function, which produces a nicely formatted date string from a JavaScript date object. The resulting strings are in the form of mmm-DD, for example Feb-07 or Jun-15.

\subsection{Render}\label{sec:render}
Following the initialization section is the render function. The render function is responsible for drawing and updating the diagram. The render function is called once in the beginning and every time the data set changes. The render function covers all data dependent tasks, including the implementation of the data joins and general update pattern. As the implementation of the render function greatly varies between the diagrams, all common features are described first. Afterwards the specifics for each diagram are described. If there are helper functions or constants required by the render function they are defined first. 

As all the diagrams make use of transitions for animations, a transition is defined with a duration of 1500 milliseconds. This transition is later called for each element which should be animated. Defining the transition here allows for all later calls to not only take the same amount of time without having to change the duration in more than one position, but also to reuse the same transition instance.

\subsubsection{Scales}
The data dependent scales in this thesis are mostly used to calculate the coordinate position and sizing of elements in the diagrams. The bar chart for example defines two scales, a linear scale to find appropriate x-coordinates and a band scale for the y-coordinates of each bar. As these scales domains depend on the value range of the provided data set, it is necessary that they are redefined with every render call.

\subsubsection{Data Joins}
After the scales are defined, the data joins are created. While some diagrams, like the bar chart, only use a single data join (see \ref{app:bar-chart} line 110), other diagrams, like the circle graph, make use of several data joins (see \ref{app:circle-graph} lines 106 and 173). Usually this is in accordance to how many independent parts the diagram consists of. The circle graph uses one data join for the size legend in the background and to update the circle showing the current data as well as the text showing the current number of total refugees.

As all diagrams in this thesis can react to data changes, they have a custom identifier function. For the refugees per country data set in this thesis, the identifier function is \verb|d => {return d.country}|.

When a data join is initially created, or when data points are added, there is not a sufficient amount of elements in the selection to pair them with data entries. D3 will therefore create empty placeholders for these elements. To make these placeholders become a part of the DOM, the \verb|.join()| function is added after the \texttt{data()} call. There are two ways to use the join function. One can either pass a string which will result in adding a matching tag to the DOM, or define functions for the general update pattern. When using the simple string method, the attributes and style for each new element can then be defined by method chaining. This approach is reasonable for diagrams that do not need to react to data changes. As all diagrams in this thesis implement the full extent of the general update pattern to be able to react to changing data and use the full potential of D3, the second approach is used.

\subsubsection{General Update Pattern}
%\textcolor{red}{
%How is this implemented? Where does it come into play?}

When the \texttt{join} function is called, instead of passing a single string as parameter, three functions can be passed as parameters. These three functions correspond to the three cases of the general update pattern and describe their respective behavior. Each of the three functions has one input parameter, corresponding to the respective sub-selection. In the enter function an element is added to the DOM. In the update function existing elements are updated to accommodate for data changes and therefore possibly removed or newly added elements as well. In the exit function elements are removed. As this is the default behavior, the exit function definition can be omitted if no extra behavior is desired. All three functions run on all the elements of the appropriate sub-selection.

The enter function adds the applicable element to the SVG. Therefore the first part of the enter function is usually an \texttt{.append(string)} call. The string describes the tag which will be added to the DOM. Afterwards the applicable styles, attributes and sub-elements are added. This can be achieved with the \texttt{.attr("attributeName", "value")}. While styles can be added with the \texttt{.style("property", "value")} function, the same can be achieved more cleanly by predefining styles in the CSS and adding applicable classes to the element. The selector used to define the current data join, should be able to match the newly created element as well. Therefore enough attributes need to be provided. This is important when the selection is recreated for updating the diagram. When positioning and sizing a new or existing element the scales are used to compute the applicable coordinate space.

The update function is necessary when the diagram should be able to react to data changes. It is usually similar to the enter function, in that it adjusts the positioning and sizing of the elements according to the possibly changes scales. 

The exit function is defined by default to simply remove the applicable elements. The diagrams is this thesis do not specify a more complex exit behavior.

All three functions can make use of animations and transitions to improve their feel. The diagrams created for this thesis only animate the enter and update behavior. Why animations are useful and how they are implemented is described in the following section.

\subsubsection{Animations}
%\textcolor{red}{
%What are they? How do they work? Why are there two kinds? What makes them tick?}

Animations can improve the feel, appeal and readability of diagrams. When a diagram is updated due to data changes, it is easier to understand and see the changes when for example bars in a bar chart shift to their new positions, instead of a seemingly entirely different diagram popping up. The animations allow the viewer to keep track of the existing entries and visually follow any changes. For example the growth or shrinking of the length of a bar in a bar chart. Animations can also be used when initially drawing the diagram, to guide viewer attention.

Animating elements in D3 is achieved by using transitions. Transitions are called on elements using the \texttt{call()} function. A transition requires a duration and can also be provided with a delay and an easing function to improve the feel. The duration and delay are both in milliseconds. Animating numerical or color values is very easy with transitions. It is only required to call the attribute or style with the target value and the transition function will calculate and show interpolated frames. This makes it very fast and easy to animate for example positioning or sizing of elements.

Instead of using the default behaviors for numbers and colors or when trying to animate other values like SVG paths, a tween function can be defined using \verb|attrTween| or \verb|styleTween|. Both tweens need to return a function which will be invoked for each frame of the animation, with a time value between 0 and 1, depending on the frame. The returned function must itself return a value, which is applied to the desired style or attribute every frame. In this thesis custom tweens are only specifically defined to animate SVG path tags in the donut chart (see listing \ref{lst:donut-chart}).


\subsubsection{Bar Chart}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
The bar chart, as well as the following implementations of the donut chart, the tree map and the Sankey graph all make use of the dataset containing the number of refugees per country they fled to.

The bar charts first defines two scales, the \texttt{xScale} as well as the \texttt{yScale} (see \ref{app:bar-chart} lines 70ff). The \texttt{xScale} is a linear scale to convert from a domain of the refugees [0, HighestNumberOfRefugeesInAnyCountry] to a range of the available space [0, contentWidth]. This allows to find the appropriate x-coordinate for any number of refugees. It is used to draw each bar to its appropriate length. The \texttt{yScale} converts from any given country to a y-position using a scale band. Therefore the domain is defined by providing an array of all possible countries and the range is [0, contentHeight]. This allows the proper height positioning of each bar using the resulting y-coordinate.

The bar chart also makes use of axes. The y-axis shows the countries, while the x-axis shows the amount of refugees. D3 has predefined functions to create axes from scales. An axis in D3 consists of many ticks. By default each tick has a label and a small line indicating its position. Furthermore there is a start and end line to indicate the whole domain. The bar chart removes all the domain lines for styling reasons. The tick lines for the y-axis are also removed, as they are unnecessary here. The tick lines of the x-axis are extended to cover the whole diagrams height. This is done to have a proper reference to read out the bars length.

\begin{minipage}{0.9\linewidth}
    \begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={The x axis implementation of the bar chart. The first constant defines the tick format. The provided '.2s' means that each number will be convert to have two significant digits. As the zero value is therefore represented as "0.0" to match the previous rule of two significant digits, it is simply replaced by "0". The second constant defines the function creating the axis. The previous tick format is passed here. Furthermore the \texttt{tickSize} is set to the height of the diagram. This way the initially small tick lines now cover the whole height of the diagram and allow for easier and more accurate readouts. Finally the \texttt{xAxisParentGroup} element, which is part of the permantent hierarchical structure of the bar chart, calls the \texttt{xAxis} function. This adds the Axis to the diagram. As a last step the domain lines are selected and removed for styling reasons. (Section from \ref{app:bar-chart} lines 91ff)}, label={lst:bar-chart-axes}]
const xAxisTickFormat = number =>
    d3.format('.2s')(number)
        .replace('0.0', '0');

const xAxis = d3.axisBottom(xScale)
    .tickFormat(xAxisTickFormat)
    .tickSize(-contentHeight);

xAxisParentGroup.call(xAxis)
    .attr('transform', `translate(0,${contentHeight})`)
    .select('.domain')
        .remove();
    \end{lstlisting}
\end{minipage}

Each bar in the bar chart is composed of a SVG \texttt{rect} for the bar itself and a \texttt{text} field as the label with the precise amount of refugees. The \texttt{rect} and \texttt{text} are both children of one group element with the \texttt{bar} class as attribute. Due to this structure, the bar chart only requires a single data join. The required selector matches all group elements with the \texttt{bar} class. In the enter sub-selection of the general update pattern, first a new group element with the \texttt{bar} class is added. Afterwards a \texttt{rect} as well as a \texttt{text} are added to the newly created group element. The \texttt{rect} is filled with the appropriate color by calling the color scale. Both elements are positioned and sized accordingly using the previously defined scales. The x-position of the text as well as the width of the rect are initialized with a zero value. These two values are animated using a transition, to reach their actual values. This way new bars always build themselves up from the left side. The text field usually tries to stick to the inner right side of the rect. In cases where there is not enough space available to the left, as the bar is shorter than the number to show, the text is placed to the right of the rect.

Elements in the update sub-selection are resized in the width and text value if the number of refugees for this country or the range of the \texttt{xScale} changed. They might also be repositioned and resized in height, as new countries are added, or old ones removed from the data set. All resizing is done using the transition for smooth animation of the changes. Elements in the exit selection are simply removed.

\subsubsection{Donut chart}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}

As the donut chart shows the total amount of refugees in the center, this value is computed first. This is achieved using the \texttt{d3.sum(data, d => d.refugees)} function (see \ref{app:donut-chart} line 115). It creates the sum of all entries in the data, using the \texttt{refugees} field for each entry. After calculating this value, the appropriate text field is updated to contain the new number.

As each section of the donut chart is made up of a path element, D3 provides two functions to generate pie and donut charts. The \texttt{d3.pie()} function calculates the appropriate start and end angle of each data point (see \ref{app:donut-chart} lines 112ff). A padding angle has also been specified for some spacing between the sections of the diagram. The \texttt{d3.pie()} function returns a new object which holds a reference to our original data, additionally to the new sections information. 

The \texttt{d3.arc()} function is set up with an inner and an outer radius (see \ref{app:donut-chart} lines 127ff). Having an inner radius of zero generates a pie chart, whereas an inner radius greater than zero, like in this instance, creates a donut chart. The \texttt{d3.arc()} function which is set up here is later used in the general update pattern to generate SVG path objects from the pie pieces containing the start and end angles of each section.

As each section of the donut chart is made up of a \texttt{path} element nested inside a group element, the selector for the data join matches all group elements with the \texttt{arc} class. The data join is then created using the previously created pie object. In the enter selection of the general update pattern, the parent group element is created first and provided with the \texttt{arc} class. Afterwards a path element is added to this group element. This path element is colored according to the color scale. Drawing the actual arc piece is done using an attribute tween. This animates the donut chart to smoothly fill itself in the beginning. The implementation of this initial animation is almost same as the one seen in \ref{lst:donut-chart} for updating the arc sections. The only difference lies in the two \texttt{interpolate} functions using zero as initial value instead of the respective \texttt{previousStartAngle} and \texttt{previousEndAngle}, as these two values are not assigned yet.

Lastly the path elements are registered to two callbacks, \texttt{mouseover} and \texttt{mouseout} using D3s \texttt{.on()} function (see \ref{app:donut-chart} lines 171 and 178). Both these events are used to show and update the appropriate text in the center of the donut chart. The effect which creates an outline around the currently hovered over path element is not linked to these events, but instead is achieved by CSS styling.

As the update behavior of the donut chart consists only of updating the paths, it is fully described in listing \ref{lst:donut-chart}. The exit behavior removes appropriate sections.

\begin{minipage}{0.9\linewidth}
    \begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={The implementation of the arc update animations. As the core of the animation is used by the enter and the update behavior, it is defined first. The new values for start and end angle are stored on the node itself. This needs to be done to be able to reference these values again for the next update, as the previous angles will not be accessible through the pie object after regenerating it for an update. Finally the function which is called for each frame of the animation is defined and returned. This function first interpolates the start and end angle values using the passed interpolation functions and the time value. This time value is in the range of zero to one, depending on how far along the animation is. These newly interpolated angles define the start and end angle of the pie piece, which is then turned into a path element by calling the \texttt{arc} function for this pie piece. As the interpolate functions \texttt{interpolateStartAngle} and \texttt{interpolateEndAngle} differ for the enter and update behavior, they are defined in the respective sections. They are passed into the core \texttt{animate} function. (Section from \ref{app:donut-chart} lines 132ff and 186ff)}, label={lst:donut-chart}]
// The core of the donut animation is defined here.
const animate = (nodes, index, d, i, j) => {
    nodes[index].previousStartAngle = d.startAngle;
    nodes[index].previousEndAngle = d.endAngle;
    
    return time => {
        d.startAngle = i(time);
        d.endAngle = j(time);
        return arc(d);
    };
};

[...].call(update => update.transition(t)
    // The update animation for the donut pieces is specified here.
    .attrTween('d', (section, index, nodes) => {
        const interpolateStartAngle = d3.interpolate(nodes[index].previousStartAngle, section.startAngle);
        const interpolateEndAngle = d3.interpolate(nodes[index].previousEndAngle, section.endAngle);

        return animate(nodes, index, section, interpolateStartAngle, interpolateEndAngle);
    }));
    \end{lstlisting}
\end{minipage}


\subsubsection{Tree map}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
As the tree map is intended to work with hierarchical data, it requires all data points to have a link to their parent data point. There is only one data point without a link to a parent, which serves as the root element. As the refugees per country data set is not in hierarchical structure, this is simulated first. Therefore a dummy object is added to the data array. Using the \texttt{d3.stratify()} command turns the data set into a tree object by connecting each data point to a parent, in this case the dummy object (see \ref{app:tree-map} line 108ff). The dummy element has no parent and serves as the root of the tree object. After removing the dummy element from the data again, the sum of refugees in the tree object is calculated. Using the \texttt{d3.treemap} command and providing it with information about the available space and padding between elements, it provides the trees leafs with their relevant size and position information (see \ref{app:tree-map} line 124ff).

The general update pattern adds a \texttt{rect} for each leaf of the tree object before styling it appropriately and animating its size and position. The \texttt{mouseover}, \texttt{mousemove} and \texttt{mouseout} events are registered for showing, updating and hiding the tooltips content and position, as the mouse moves over a \texttt{rect} in the tree map. The update selection smoothly moves and resizes the rects when applicable, while the exit selection removes them.


\subsubsection{Sankey diagram}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
The Sankey diagram consists of nodes and links. Therefore these two arrays are constructed first. Each node represents one country. The links describe the flow of values, in this case refugees, between nodes. This is achieved by providing a source node, a target node and the value at the target node. To be able to show a flow from the Ukraine to the other countries, the Ukraine is added as a node. All countries from the data set are added as nodes. There is also a link from the Ukraine node created for every country. The resulting arrays are provided to the \texttt{d3.sankey()} function (see \ref{app:sankey} line 73ff). This function is not part of the default D3 namespace. Instead it is added by additionally importing the Sankey package in the Sankey diagrams HTML page header. The \texttt{d3.sankey()} function adds additional information to the nodes and links allowing for appropriate placement of the according elements. It also adds all the links' values to create a source value for the Ukraine node.

The Sankey diagram makes use of two data joins. The first one links the nodes to appropriate group elements. During the enter behavior, each group elements is filled with a \texttt{rect} and a \texttt{text} element. The \texttt{rect} represents a node in the Sankey diagram and is sized according to the number of refugees and styled according to the country using the color scale. To make the color scale consistent with the other diagrams, the Ukraine node is provided with a fixed color. This prevents the Ukraine node from querying the color scale and creating inconsistency with the other diagrams which do not contain a representation for the Ukraine. The \texttt{text} label contains the name and amount of refugees per country. It is placed next to the appropriate \texttt{rect}s. This can be on the left or rights side, depending on the x-position of the rects. If the rect is in the left half of the diagram the label is right, if the rect is in the right half the label is left. Both rect and text make use of transitions to smoothly build up the diagram. The text also makes use of a small delay to the transition by using the \texttt{.delay(100)} function (see \ref{app:sankey} line 124).

The second data join takes care of the links. They are matched to path elements. Each path is styled to match the country it leads to. The required SVG path is created using the \texttt{d3.sankeyLinkHorizontal()} command (see \ref{app:sankey} line 149). As the resulting path is only a single line, the \texttt{stroke-width} attribute corresponds to the width of the link. The links are also animated using the transition. When initially appearing, the links are provided with a delay before fading into existence after the nodes have settled in their positions. The update behavior makes sure that the links are smoothly transitioned to their necessarily position and the width adjusted as needed.

\subsubsection{Circle graph}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
The circle graph, as well as the area graph described in the following section both make use of the data set about the cumulative refugees per day.

The circle graph makes use of two data dependent scales. A time scale is created using \texttt{d3.scaleQuantize()} (see \ref{app:circle-graph} line 85ff). It is used for converting the time slider value to an actual date. As the time slider value provides a value between zero and one, this domain is mapped to the range of available dates in the data set. The second scale is used to get the correct radius of the circle. Because the area of the circle corresponds to the number of refugees, it is important to not scale the radius linearly. This would lead to circle areas which do not represent the correct number of refugees. Scaling the radius linearly would introduce a lie-factor higher than one. In fact, due to the relation between a linear change in radius and a change which keeps the area consistent, the lie factor increases, the higher the amount of refugees is. To avoid this, a \texttt{d3.scaleSqrt()} is used (see \ref{app:circle-graph} line 90). The domain is set to [0, HighestNumberOfTotalRefugees] and the range to [0, contentHeight/2]. This scale is also used for drawing the background legend. This is achieved by getting the ticks of the scale and saving the appropriate values in an array. This array is rendered in circles using the first data join. This data join draws and updates a circle and a text label for each tick.

As the actual content of the diagram does not draw one mark per data point, the refugee number for only one data entry is shown at a time. The time scale is used to determine which is the currently selected date from the time value, provided by the slider, in the range of zero to one. The resulting date is used to get the corresponding data for that date from the data set. This allows the diagram to reuse only use one circle and one text label in its representation. Therefore the second data join also looks a bit different. Instead of linking actual data, an array with an arbitrary single entry is linked to the selection. Without this single element, D3 would not draw the circle, as it assumes that there is no data to show. The identifier function also always returns the same value, no matter what data was linked. This makes sure that the same circle element is matched by the selector on each render call, as to not draw a new circle every time the diagram is supposed to update. The circle and text are both created and styled using the data which was found for the current date.

\subsubsection{Area graph}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}

The area graph makes use of the same time scale as the circle graph. Additionally it uses a linear scale for the y-axis and a scale band for the x-axis. The y-axis represents the number of refugees, while the x-axis shows the days. Both axes are added to the diagram in the same way as is done in the bar chart. As showing all days on the x-axis would be too dense, the values are filtered and only 15 equidistant days are shown. This is achieved by using JavaScript \texttt{filter} function for arrays and specifying a custom filter which is to be evaluated for each entry in the domain of the x-axis scale band (see \ref{app:area-graph} line 126).

The main content of the area graph consists of two parts. One part shows the area, while the other one is the date line showing the current date. The area and the line following along the top of the area, the top-line, are two separate path elements. Their definition can be seen in listing \ref{lst:line-area}. Because the area and line both cover the whole range of data at once, the data join, which creates and updates them, uses the same single element dummy data as the circle graph. When creating or updating the line and area, the whole data set is passed to the respective functions.

\begin{minipage}{0.9\linewidth}
    \begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={The first constant defines the function for creating the top-line of the area graph. This is achieved by specifying functions for x- and y-values. D3 uses them to calculate the position of each point on the line. Using the arrow functions here applies this for each entry of the data set which is passed as a parameter when calling this function. When the function is called and a data set is provided, by calling \texttt{line(data)}, the line is constructed by calculating the according x- and y-positions for every data point. Defining and creating the area works in similar fashion. Yet there are two y-positions for each x-position. \texttt{y0} is the bottom of the shape, while \texttt{y1} is the top. Switching the definition of \texttt{y0} and \texttt{y1} results in a reversed direction of the SVG path describing the outline of the shape. The \texttt{d3.area()} function allows for a huge variety of shapes. Yet it is not possible to create concave ends on the right or left side of the shape, assuming left and rigth are oriented horizontally. Of course the created shape can be rotated and oriented using all possible SVG tags and attributes. (Section from \ref{app:area-graph} lines 144ff)}, label={lst:line-area}]
const line = d3.line()
    .x(d => xScaleWithOffset(d.date))
    .y(d => yScale(d.refugees));

const area = d3.area()
    .x(d => xScaleWithOffset(d.date))
    .y1(contentHeight)
    .y0(d => yScale(d.refugees));
    \end{lstlisting}
\end{minipage}

The date line is made up of three elements. A circle element rides on the top line of the area, a vertical line to indicate the current day on the x-axis and a text label to show the days refugee value. All three parts are simply created and updated in the second data join. This data join makes use of the same kind of dummy data as seen in the previous data join and the circle graph.


\section{Showcase} \label{sec:showcase}
%\textcolor{red}{
%How is the showcase structured? How can you get there? Why does it exist? Who might benefit? How can you reuse a part the interesting parts?}
To bring all the diagrams together, a showcase has been created. In addition to containing the diagrams, it also allows for manually modifying the data used to create the diagrams. The layout of the showcase as well as how data can be modified are described in the following sections.

\subsection{Layout}
The showcase is split into two main sections. The first section is about the refugees per neighbor country they crossed into. The second section is about the cumulative refugees over time. As all diagrams in one section represent the same data set it allows for an easy visual comparison. While the left side of each of the two section holds all the diagrams, the right side contains information regarding the diagrams, as well as a possibility to view and change data. The information area always tries to stick to the top of the screen, as long as space is available.

The information area of the first section shows a legend first. This legend is implemented using D3 and reacts to data changes like the diagrams do. The information area of the second section contains a time slider. This is used to select the current date which the circle and area graph take into account. 

The showcase loads each of the diagrams into a separate \texttt{iframe} tag with a consistent aspect ratio. As the diagrams are set up to use all available space in the provided container, the showcase makes sure to size the \texttt{iframe} containers appropriately. When a diagram is loaded in the showcase, it also registers with the applicable data service. This allows the data service to update the diagram as the data is changed, as is described in the following section.

\subsection{Data Updates}
%\textcolor{red}{
%How can you simulate data changes? Why is this useful?}

Each section of the showcase has a table which allows for data manipulation. These tables are hidden when the showcase is loaded. They can be shown by ticking the appropriate 'Show Data' checkbox. Rows of data can be modified, added or removed here. The data changes here are not persistent and are therefore not saved in the original data files. While the correctness of the initial data is not guaranteed, arbitrarily changing the data entries obviously falsifies the shown data. Changes in the data are registered by the respective data service when a data update is triggered. Data updates are triggered automatically as soon as any data is changed or rows are added or removed while the 'Auto Update' checkbox is ticked. This is the default case. If one wants to change more data points before a update is triggered, the auto update option can be deselected and the manual 'Update Data' button used instead. When a update is triggered, the data service creates a new data set from the data in the table and passes it along to the applicable diagrams when calling their render function to update.

For this thesis it is important to be able to modify the data, as one of the core features of D3 tested in this thesis is reacting to changes in data. This manual style of modifying data is probably not so common in real world applications. Yet it is easy to replace these manual data changes to regular API calls or other automatically updating data sources. As the source of the data changes does not matter for the functionality of D3, the manual approach chosen here is sufficient in demonstrating the possibilities of D3 in reacting to changing data.
