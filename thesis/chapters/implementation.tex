\chapter{Implementation}
%\textcolor{red}{

%How are the chosen diagrams implemented? Which D3 modules have been used? How was the implementation done?}

In the following sections the process of creating the showcase and the diagrams are described. There are several parts to this. At first the data-sets, which should be represented, are chosen. In most real world usages, this is already given. Afterwards the possible diagrams are considered and chosen. Their implementation and usages of D3 are described. Finally the showcase bringing all the diagrams together is described.

\section{Datasets}
%\textcolor{red}{
%What are our datasets about? Where do they come from?}
As different data-types allow for different representations and require varying parts of D3, the data used in this thesis has been specifically chosen to contain both types of categorical as well as numeric data. As there are no differences in the implementation of discrete and continuous data, no extra efforts was done to cover both these types.

All data used for the creation of the diagrams in this thesis originates from UNHCR Ukraine refugee situation page\cite{unhcr}. The dataset about total cumulative border crossings from Ukraine per day\cite{unhcr_rpd} is in JSON format. The data about the border crossings into countries featured in the refugee response plan, as well as into other neighboring countries\cite{unhcr} were extracted directly as CSVs. While all data reference border crossings from Ukraine and not refugees directly, the UNHCR states that "[they do] not count border crossings of individuals from bordering countries leaving Ukraine to return home (i.e. Romanians returning to Romania), nonetheless among those forced to flee Ukraine are also Ukrainian nationals with dual citizenship"\cite{unhcr_note}. Therefore this thesis will henceforth use the refugee terminology.
The refugees per country cover a time-span between february 24th 2022 up until august 16th 2022\cite{unhcr}. The refugees per day cover the time from february 24th 2022 until july 17th 2022\cite{unhcr_rpd}.


%(Due to the currentness of the situation, the UNHCR only recently changed to using border crossings from Ukraine. Previously these were referred to as refugees fleeing Ukraine. As the implementation was already completed at this point and because it makes no difference to the workings of D3, this thesis will henceforth use the refugee wording again.)


To keep the implementations of the diagrams as simple as possible, some data preprocessing was done. Therefore two data service JavaScript files have been created. The first JavaScript file, the countryDataService.js reads both csv files containing information about the refugees fleeing into all neighboring countries. Both files are then combined to one data array containing an object, with properties for country and refugees, for each data entry. The second data service, the dailyDataService.js, reads the JSON file containing information about the total refugees per day. As this JSON file contains a lot of filler data, which is not needed, the data service strips all unnecessarily information away and produces a single array. This array contains an object, with properties for date and refugees, for each data entry. Both data services pass the data to the applicable diagrams. The data services are also responsible for filling the data tables in the showcase and pass along any data changes done here to the applicable diagrams.


Together both resulting data-sets contain most of the data types. The number of refugees, which can be found in both data-sets, is a discrete attribute. The countries in one data-set are a nominal attribute. The date in the other data-set is a ordinal attribute instead.



%It would be possible to use both these data-sets as is. Yet the vast amounts of filler data, which does not contain any valuable information, makes data accesses unnecessarily complicated and hard to follow along and understand the diagrams implementations. Therefore both data-sets are preprocessed. In both cases the data-sets are read and the valuable information extracted and saved in the CSV format. Both of the newly created CSV files have two columns and one header row. The resulting CSV of the refugees per country dataset, contains the two columns of country and refugees. The other resulting CSV contains a column for the date and one for the cumulative refugees. 

%(The data-set about the refugees per country can also easily be converted into using percentages. After adding up the total amount of refugees from each data-point, one can convert the absolute number of refugees into percent.)

%\subsection{Data Types}
%\textcolor{red}{
%Which data types can be found in our data-sets? Where?}

%The two chosen data-sets already cover most of the data-types. Both dataset contain two attributes per data-point. The country is a categorical attribute. The number of refugees is discrete. When converting this data-set into percentages, the percentage of refugees becomes a continuous attribute. In the refugees per date data-set, the amount of refugees is still a discrete attribute. The date itself is an ordinal attribute though. As one day clearly comes before and after other days.

%Choosing data-sets which cover all types of data-types was an important consideration. Different data-types can have different ways of representation, as well as different ways of implementation on the programming side of things.


\section{Diagrams}
%\textcolor{red}{
%describe all the diagrams and why they are special and what makes them tick. Why have they been chosen?}

The following section is about the selection and implementation of each diagram. Whilst all diagrams are presented in one showcase, each diagrams is implemented to work standalone. This makes the comparison between diagrams, as well as evaluating the effort needed to create them easier. It also allows for easier adaptation if one is to use one of the diagrams as a template. Therefore all diagrams follow the same pattern. As each diagram is independent, they all consist of three parts. A HTML, a CSS and a JavaScript file. The HTML loads the D3 library in the header. The body of the HTML consists of a svg tag where the diagram will be drawn, and a script tag which loads the JavaScript file. The CSS defines the general styling of the diagram which is not dependent on the input data. The main part of the implementation is done in the Javascript section.

The JavaScript file also follows a general pattern. At first there is a initialization section which is run once as the website is loaded. It is followed by a render function which is responsible for drawing and updating the diagram. 

\subsection{Initialization}
Generally all things which are data independent are done during the initialization. It starts with setting some core variables. A reference to the svg tag which will be used as the container is made. It is followed by a margin definition, where the margin of our diagram content in relation to the container size is defined. The resulting values for \verb|ourHeight| and \verb|ourWidth|, which we will use as space to draw the diagram, are saved. 

Following there are a few group elements which are added to the svg tag. These group elements provide a general hierarchy for different aspects of the diagram. For example the bar chart has separate groups for the axes and the content, while the circle diagram has groups for the background legend and the content. Having a proper structure in place makes working with selections easier as well as helping with human readability of the svg's content. This general hierarchy is only created to a level which is independent of the provided data.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=htmlcssjs, caption={JavaScript code to create the hierarchy as used in the bar-chart}, label={hierarchy_creation}]
const diagramGroup = svg.append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

const xAxisParentGroup = diagramGroup.append('g')
    .attr('id', 'xAxis')

const yAxisParentGroup = diagramGroup.append('g')
    .attr('id', 'yAxis')

const contentParentGroup = diagramGroup.append('g')
    .attr('id', 'content')
\end{lstlisting}
\begin{lstlisting}[style=htmlcssjs, caption={Resulting HTML structure}, label={hierarchy_result}]
<svg>
    <g transform=translate(118,20)>
        <g id="xAxis"></g>
        <g id="yAxis"></g>
        <g id="content"></g>
    </g>
</svg>
    \end{lstlisting}
\end{minipage}


If there data independent scales, they are defined here. A common example here is a color scale for discrete values. It is used in all diagrams showing the refugees per country. It is not important to already know the specific input values, to be able to create a list of colors which is used by the scale. When queried, it will then return a new color from the list, for each new query value. It is important to note that when the color list runs out of new colors, it restarts at the beginning of the list.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=htmlcssjs, caption={Definition of data independent color scale}, label={color_scale}]
const colors = d3.scaleOrdinal(d3.schemeDark2);
\end{lstlisting}
\end{minipage}

Finally if there are any static elements, they are also defined in the initialization. For example the tooltip used by the tree-map or the center text fields in the donut-chart. They are already created here, so they can be filled with appropriate data later.

\subsection{Render}
Following the initialization section is the render function. The render function is called once in the beginning and every time the provided data changes. The render function covers all data dependent tasks. If there are helper functions or constants required by the render function they are defined first. Following this all the data dependent scales are defined.

\subsubsection{Scales}
The data dependent scales in this thesis are mostly used to acquire the coordinate position and sizing of elements in the diagrams. The bar-chart for example defines two scales. A linear scale to convert from a domain of the refugees [0-MaxNumberOfRefugeesInACountry] to a domain of the available space [0-ourWidth]. Converting from any given country to a y position is done using a scale band. As both these scales depend on the provided data, they are redefined with every render call.

\subsubsection{Data Joins}
After the scales are defined, the data joins are created. While some diagrams, like the bar-chart, only use a single data-join, other diagrams, like the circle-diagram, make use of several data joins. Usually this is in accordance to how many independent parts the diagram consists of. The circle diagram uses one data join for the size legend in the background, one to update the circle showing the current data and one to update the text showing the current number of total refugees.

A data join is created when binding data to a selection. This is achieved by first calling the \verb|.data(DATA)| function of a selection. The data function creates pairs of elements and data entries. By default, these are matched through their index in the selection and data arrays. This can lead to unexpected behavior when entries are removed or inserted at the not last position. Therefore the default identifier function can be overwritten by passing a custom identifier function as the second optional parameter to the data function. A custom identifier function should return a value and is called for each element in the data array. For the refugees per country data-set in this thesis, the identifier is usually \verb|d => {return d.country}|.

When we initially create the data join, or when data-points are added, we do not have sufficient elements in the selection to pair them with data entries. D3 will therefore create empty placeholders for these elements. To make these placeholders become a part of the DOM, we add the \verb|.join()| after the data() call. There are two ways to use the join function. We can either pass a string which will result in adding a matching tag to the DOM. The attributes and style for each new element can then be defined by method chaining. This approach is reasonable for diagrams that do not need to react to daa changes. In this thesis we want all diagrams to implement the full extend of the general update pattern, to be able to react to changing data and use the full possibilities of D3.

\subsubsection{General Update Pattern}
%\textcolor{red}{
%How is this implemented? Where does it come into play?}

When the join function is called, instead of passing a single string as parameter, three functions can be passed as parameters. These three functions correspond to the three cases of the general update pattern and describe their respective behavior. Each of the three function has one input parameter, corresponding to the respective sub-selection. In the enter function usually a element is added to the DOM. In the exit selection we remove elements again. The update function is optional, but always used in this thesis, as this is the place to update existing elements to accommodate for data changes and therefore possibly removed or newly added elements as well. All three functions run on all the elements of the appropriate sub-selection.

The enter function should add the applicable placeholder element to the svg as actual content. Therefore the first part of the enter function is usually an \verb|.append(string)| call. The string describes the tag which will be added to the DOM. Following this the applicable styles, attributes and sub-elements are added. This can be achieved with the \verb|.attr("attributeName", "value")|. Whilst styles can be added with the \verb|.style("property", "value")| function, the same can be achieved by predefining styles in the css and adding applicable classes to the element. It is important to add enough attributes, that the provided selector which was used to create the selection for the data join whose behavior we are defining, can also match the newly created element when called again for an update. When positioning a new or existing element the  scales are used to find the applicable coordinate space.

The update function is necessary when we want to react to data changes. It is usually similar to the enter function, in that is adjusts the positioning and sizing of the elements according to the possibly changes scales. The exit function is defined by default to simply remove the applicable elements.

All three functions can make use of animations and transitions to improve their feel.

\subsubsection{Animations}
%\textcolor{red}{
%What are they? How do they work? Why are there two kinds? What makes them tick?}

Animations can improve the feel, appeal and readability of diagrams. Especially when reacting to data changes, it is easier to understand and see the changes when for example bars in a bar-chart shift to their new positions, instead of a seemingly entirely new diagram popping up out of thin air. The animations allow the viewer to keep track of the existing entries and visually follow any changes. It is also possible to see the changes of existing values by following, for example, the growth or shrinking of the length of a bar in a bar-chart. Animations can also be used when initially drawing the diagram, to guide viewer attention.

Animating elements in D3 is achieved by using transitions. Transitions are called from a selection and run on all the elements of the selection. A transition requires a duration and can also be provided with a delay and an easing function. The duration and delay are both in milliseconds. Animating numerical, color or string values is very easy with transition. It is only required to call the attribute or style with the target value and the transition will take care of the rest. This makes it very fast and easy to animate for example positioning or sizing.

\begin{lstlisting}[style=htmlcssjs]
    enter.call(enter => enter.transition(t)
    .attrTween('d', (d, index, nodes) => {
            const i = d3.interpolate(0, d.startAngle);
            const j = d3.interpolate(0, d.endAngle);

            nodes[index].previousStartAngle = d.startAngle;
            nodes[index].previousEndAngle = d.endAngle;

            return time => {
                d.startAngle = i(time);
                d.endAngle = j(time);
                return arc(d);
            }}))
\end{lstlisting}

Instead of using the default behaviors for numbers, string and colors or when trying to animate other values like svg paths, a tween function can be defined using \verb|attrTween| or \verb|styleTween|. Both tweens need to return a function which will be invoked for each frame of the animation, with a time value between 0 and 1, depending on the frame. The returned function must itself return a value, which is applied to the desired style or attribute every frame. In this thesis tweens are only specifically defined to animate svg path tags.


\subsection{Bar Chart}
\textcolor{red}{
How does it work? Which d3 features does it use? how do they work?}

\subsection{Pie chart}
\textcolor{red}{
How does it work? Which d3 features does it use? how do they work?}

\subsection{Tree map}
\textcolor{red}{
How does it work? Which d3 features does it use? how do they work?}

\subsection{Sankey}
\textcolor{red}{
How does it work? Which d3 features does it use? how do they work?}

\subsection{Area graph}
\textcolor{red}{
How does it work? Which d3 features does it use? how do they work?}

\subsection{Circle graph}
\textcolor{red}{
How does it work? Which d3 features does it use? how do they work?}


\section{Showcase}
%\textcolor{red}{
%How is the showcase structured? How can you get there? Why does it exist? Who might benefit? How can you reuse a part the interesting parts?}

To bring all the diagrams together, a showcase has been created. It  is split into two main parts. Firstly all the diagrams for refugees per country are covered. Secondly the diagrams for refugees over time are shown. As all diagrams in one section represent the same data-set, it allows for an easy visual comparison, as well as easier comparison of the code. When each diagram would show different data, it would be harder to distinguish between implementation differences which are due to the different representation and differences which are caused by accommodating different data-sets. Additionally each section has a table where the input data can be seen and modified.

\subsection{Integration of each diagram}
%\textcolor{red}{
%How is each diagram integrated? How can you access them? Where can you grab them standalone?}

Each diagram is implemented to work on its own and without the showcase. Each diagram is also designed to use all the space available in its container. When loading one of the diagrams HTMLs directly, it will therefore fill the whole browser window. The showcase loads each of the diagrams into a separate IFrame tag with a consistent aspect ratio.

\subsection{Data Updates}
%\textcolor{red}{
%How can you simulate data changes? Why is this useful?}

Each section of the showcase has a table which allows for data manipulation. Rows of data can be modified, added or removed here. The data changes here are not persistent and therefore do not get written in the original data csv files. When data is changed, the diagrams are provided with the updated data and adapt accordingly. For this thesis it is important to be able to modify the data, as one of the core features of D3 tested in this thesis is reacting to changes in data. This manual style of changing data is probably not so common in real world applications. Yet it is easy to replace these manual data changes to regular API calls or other automatically updating data-sources. As the source of the data changes does not matter for the functionality of D3, the manual approach chosen here is sufficient in demonstrating the possibilities of D3.
