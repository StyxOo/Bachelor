\chapter{Implementation}
%\textcolor{red}{

%How are the chosen diagrams implemented? Which D3 modules have been used? How was the implementation done?}

In the following sections the process of creating the showcase and the diagrams are described. There are several parts to this. At first the data-sets, which should be represented, are chosen. In most real world usages, this is already given. Afterwards the possible diagrams are considered and chosen. Their implementation and usages of D3 are described. Finally the showcase bringing all the diagrams together is described.

\section{Datasets}
%\textcolor{red}{
%What are our datasets about? Where do they come from?}
As different data-types allow for different representations and require varying parts of D3, the data used in this thesis has been specifically chosen to contain both types of categorical as well as numeric data. As there are no differences in the implementation of discrete and continuous data, no extra efforts was done to cover both these types.

All data used for the creation of the diagrams in this thesis originates from UNHCR Ukraine refugee situation page\cite{unhcr}. The dataset about total cumulative border crossings from Ukraine per day\cite{unhcr_rpd} is in JSON format. The data about the border crossings into countries featured in the refugee response plan, as well as into other neighboring countries\cite{unhcr} were extracted directly as CSVs. While all data reference border crossings from Ukraine and not refugees directly, the UNHCR states that "[they do] not count border crossings of individuals from bordering countries leaving Ukraine to return home (i.e. Romanians returning to Romania), nonetheless among those forced to flee Ukraine are also Ukrainian nationals with dual citizenship"\cite{unhcr_note}. Therefore this thesis will henceforth use the refugee terminology.
The refugees per country cover a time-span between february 24th 2022 up until august 16th 2022\cite{unhcr}. The refugees per day cover the time from february 24th 2022 until july 17th 2022\cite{unhcr_rpd}.


%(Due to the currentness of the situation, the UNHCR only recently changed to using border crossings from Ukraine. Previously these were referred to as refugees fleeing Ukraine. As the implementation was already completed at this point and because it makes no difference to the workings of D3, this thesis will henceforth use the refugee wording again.)


To keep the implementations of the diagrams as simple as possible, some data preprocessing was done. Therefore two data service JavaScript files have been created. The first JavaScript file, the countryDataService.js reads both csv files containing information about the refugees fleeing into all neighboring countries. Both files are then combined to one data array containing an object, with properties for country and refugees, for each data entry. The second data service, the dailyDataService.js, reads the JSON file containing information about the total refugees per day. As this JSON file contains a lot of filler data, which is not needed, the data service strips all unnecessarily information away and produces a single array. This array contains an object, with properties for date and refugees, for each data entry. Both data services pass the data to the applicable diagrams. The data services are also responsible for filling the data tables in the showcase and pass along any data changes done here to the applicable diagrams.


Together both resulting data-sets contain most of the data types. The number of refugees, which can be found in both data-sets, is a discrete attribute. The countries in one data-set are a nominal attribute. The date in the other data-set is a ordinal attribute instead.



%It would be possible to use both these data-sets as is. Yet the vast amounts of filler data, which does not contain any valuable information, makes data accesses unnecessarily complicated and hard to follow along and understand the diagrams implementations. Therefore both data-sets are preprocessed. In both cases the data-sets are read and the valuable information extracted and saved in the CSV format. Both of the newly created CSV files have two columns and one header row. The resulting CSV of the refugees per country dataset, contains the two columns of country and refugees. The other resulting CSV contains a column for the date and one for the cumulative refugees. 

%(The data-set about the refugees per country can also easily be converted into using percentages. After adding up the total amount of refugees from each data-point, one can convert the absolute number of refugees into percent.)

%\subsection{Data Types}
%\textcolor{red}{
%Which data types can be found in our data-sets? Where?}

%The two chosen data-sets already cover most of the data-types. Both dataset contain two attributes per data-point. The country is a categorical attribute. The number of refugees is discrete. When converting this data-set into percentages, the percentage of refugees becomes a continuous attribute. In the refugees per date data-set, the amount of refugees is still a discrete attribute. The date itself is an ordinal attribute though. As one day clearly comes before and after other days.

%Choosing data-sets which cover all types of data-types was an important consideration. Different data-types can have different ways of representation, as well as different ways of implementation on the programming side of things.


\section{Diagrams}
%\textcolor{red}{
%describe all the diagrams and why they are special and what makes them tick. Why have they been chosen?}

The following section is about the selection and implementation of each diagram. Whilst all diagrams are presented in one showcase, each diagrams is implemented to work standalone. This makes the comparison between diagrams, as well as evaluating the effort needed to create them easier. It also allows for easier adaptation if one is to use one of the diagrams as a template. Therefore all diagrams follow the same pattern. As each diagram is independent, they all consist of three parts. A HTML, a CSS and a JavaScript file.  The HTML loads the D3 library in the header. The body of the HTML consists of a svg tag where the diagram will be drawn, and a script tag which loads the JavaScript file. The CSS defines the general styling of the diagram which is not dependent on the input data. The main part of the implementation is done in the Javascript section.Additionally each diagram requires access to its respective data service.

The JavaScript file also follows a general pattern. At first there is a initialization section which is run once as the website is loaded. It is followed by a render function which is responsible for drawing and updating the diagram. Both are explained in the following subsections.

\subsection{Initialization}
Generally all things which are data independent are done during the initialization. It starts with setting some core variables. A reference to the SVG tag, which will be used as the container for the diagram, is made. It is followed by a margin definition for all four sides, where the margin of our diagram content in relation to the container size is defined. The resulting values for \verb|ourHeight| and \verb|ourWidth|, which are used as space to draw the diagram, are saved. 

Following there are a few group elements which are added to the svg tag. Adding elements is achieved by calling \verb|.append('elementName')| on an existing element. In the first case, this is the previously stored reference to the SVG. As the \verb|append| command returns the newly created element, it can be directly stored in a variable for later reference, or provided with attributes via method chaining.  This can be seen in listing \ref{lst:hierarchy_creation}.

The group elements added here provide a general hierarchy for different aspects of the diagram. Having a proper structure in place makes working with selections easier as well as helping with human readability of the SVGs content. This general hierarchy is only created to a level which is independent of the provided data and differs depending on the type of diagram. For example the bar chart has separate groups for the axes and the content, see listing \ref{lst:hierarchy_result}, while the circle diagram has groups for the background legend and the content.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=htmlcssjs, captionpos=b, caption={JavaScript code to create the hierarchy as used in the bar-chart. The first line adds a new group element to themain SVG container using the \texttt{append} command. The newly added group element is saved in a constant for later references. Furthermore in line two an attribute is added to the new group element using the \texttt{attr} command and method chaining. It moves the group element from the left and top to allign with the margin definition. In each of the lines four, seven and ten, another group element is added. They are added to the previously created group element. They are all stored in constants for later reference and are provided with id's for easier identification and debugging.}, label={lst:hierarchy_creation}]
const diagramGroup = svg.append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

const xAxisParentGroup = diagramGroup.append('g')
    .attr('id', 'xAxis')

const yAxisParentGroup = diagramGroup.append('g')
    .attr('id', 'yAxis')

const contentParentGroup = diagramGroup.append('g')
    .attr('id', 'content')
\end{lstlisting}
\begin{lstlisting}[style=htmlcssjs, captionpos=b, caption={The HTML structure which results from the JavaScript code in listing \ref{lst:hierarchy_creation}. The resulting tree structure clearly separates the different aspects of the diagram. Using a hierarchical approach makes not only later selections easier, but also increases human readability and simplyfies debugging.}, label={lst:hierarchy_result}]
<svg>
    <g transform=translate(118,20)>
        <g id="xAxis"></g>
        <g id="yAxis"></g>
        <g id="content"></g>
    </g>
</svg>
    \end{lstlisting}
\end{minipage}


If there are data independent scales, they are defined here. A common example here is a color scale for nominal values. It is used in all diagrams showing the refugees per country. It is not important to already know the specific input values, to be able to create a list of colors which is used by the scale. When queried, it will then return a new color from the list for each new query value. Therefor this scale does not require a predefined domain. Instead it is dynamically defined and extended with each new value querying the scale. It is important to note that when the predefined color list runs out of new colors, it starts reusing the same color list from the beginning.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=htmlcssjs, caption={Definition of the data independent color scale. \texttt{d3.schemeDarkv2} is a predefined list of color values which is to be used by the scale.}, label={color_scale}]
const colors = d3.scaleOrdinal(d3.schemeDark2);
\end{lstlisting}
\end{minipage}

Finally if there are any static elements, they are also defined in the initialization. For example the tooltip used by the tree-map or the center text fields in the donut-chart. Even though the data which these fields are supposed to show is not yet known, these fields are persistent and can therefore already be created here.

\subsection{Render}
Following the initialization section is the render function. The render function is called once in the beginning and every time the provided data changes. The render function covers all data dependent tasks, including the implementation of the data-joins and general update pattern. As the implementation of the render function greatly varies between the diagrams, all common features are described first. Afterwards the specifics for each diagram are described. If there are helper functions or constants required by the render function they are defined first. 

As all the diagrams make use of transitions for animations, a transition is defined with a duration of 1500 milliseconds. This transition is later called for each element which should be animated. Defining the transition so soon, allows for all later calls to take the same amount of time, without having to change the duration in more than one position.

\subsubsection{Scales}
The data dependent scales in this thesis are mostly used to acquire the coordinate position and sizing of elements in the diagrams.  The bar-chart for example defines two scales. A linear scale to find appropriate x-coordinates and a scale band for the y-coordinates of each bar. As these scales depend on the provided data, it is necessary that they are redefined with every render call.

\subsubsection{Data Joins}
After the scales are defined, the data joins are created. While some diagrams, like the bar-chart, only use a single data-join, other diagrams, like the circle-diagram, make use of several data joins. Usually this is in accordance to how many independent parts the diagram consists of. The circle diagram uses one data join for the size legend in the background, one to update the circle showing the current data and one to update the text showing the current number of total refugees.

A data join is created when binding data to a selection. This is achieved by first calling the \verb|.data(DATA)| function of a selection. The data function creates pairs of elements and data entries. By default, these are matched through their index in the selection and data arrays. This can lead to unexpected behavior when entries are removed or inserted at the not last position. Therefore the default identifier function can be overwritten by passing a custom identifier function as the second optional parameter to the data function. A custom identifier function should return a value and is called for each element in the data array. For the refugees per country data-set in this thesis, the identifier is usually \verb|d => {return d.country}|.

When we initially create the data join, or when data-points are added, we do not have sufficient elements in the selection to pair them with data entries. D3 will therefore create empty placeholders for these elements. To make these placeholders become a part of the DOM, we add the \verb|.join()| after the data() call. There are two ways to use the join function. We can either pass a string which will result in adding a matching tag to the DOM. The attributes and style for each new element can then be defined by method chaining. This approach is reasonable for diagrams that do not need to react to daa changes. In this thesis we want all diagrams to implement the full extend of the general update pattern, to be able to react to changing data and use the full possibilities of D3.

\subsubsection{General Update Pattern}
%\textcolor{red}{
%How is this implemented? Where does it come into play?}

When the join function is called, instead of passing a single string as parameter, three functions can be passed as parameters. These three functions correspond to the three cases of the general update pattern and describe their respective behavior. Each of the three function has one input parameter, corresponding to the respective sub-selection. In the enter function usually a element is added to the DOM. In the exit selection we remove elements again. The update function is optional, but always used in this thesis, as this is the place to update existing elements to accommodate for data changes and therefore possibly removed or newly added elements as well. All three functions run on all the elements of the appropriate sub-selection.

The enter function should add the applicable placeholder element to the svg as actual content. Therefore the first part of the enter function is usually an \verb|.append(string)| call. The string describes the tag which will be added to the DOM. Following this the applicable styles, attributes and sub-elements are added. This can be achieved with the \verb|.attr("attributeName", "value")|. Whilst styles can be added with the \verb|.style("property", "value")| function, the same can be achieved by predefining styles in the css and adding applicable classes to the element. It is important to add enough attributes, that the provided selector which was used to create the selection for the data join whose behavior we are defining, can also match the newly created element when called again for an update. When positioning a new or existing element the  scales are used to find the applicable coordinate space.

The update function is necessary when we want to react to data changes. It is usually similar to the enter function, in that is adjusts the positioning and sizing of the elements according to the possibly changes scales. The exit function is defined by default to simply remove the applicable elements.

All three functions can make use of animations and transitions to improve their feel. Animating updates also allows the viewer to more easily follow and comprehend changes, compared to suddenly being shown a new diagram.

\subsubsection{Animations}
%\textcolor{red}{
%What are they? How do they work? Why are there two kinds? What makes them tick?}

Animations can improve the feel, appeal and readability of diagrams. Especially when reacting to data changes, it is easier to understand and see the changes when for example bars in a bar-chart shift to their new positions, instead of a seemingly entirely new diagram popping up out of thin air. The animations allow the viewer to keep track of the existing entries and visually follow any changes. It is also possible to see the changes of existing values by following, for example, the growth or shrinking of the length of a bar in a bar-chart. Animations can also be used when initially drawing the diagram, to guide viewer attention.

Animating elements in D3 is achieved by using transitions. Transitions are called from a selection and run on all the elements of the selection. A transition requires a duration and can also be provided with a delay and an easing function. The duration and delay are both in milliseconds. Animating numerical, color or string values is very easy with transition. It is only required to call the attribute or style with the target value and the transition will take care of the rest. This makes it very fast and easy to animate for example positioning or sizing.

\begin{lstlisting}[style=htmlcssjs]
    enter.call(enter => enter.transition(t)
    .attrTween('d', (d, index, nodes) => {
            const i = d3.interpolate(0, d.startAngle);
            const j = d3.interpolate(0, d.endAngle);

            nodes[index].previousStartAngle = d.startAngle;
            nodes[index].previousEndAngle = d.endAngle;

            return time => {
                d.startAngle = i(time);
                d.endAngle = j(time);
                return arc(d);
            }}))
\end{lstlisting}

Instead of using the default behaviors for numbers, string and colors or when trying to animate other values like svg paths, a tween function can be defined using \verb|attrTween| or \verb|styleTween|. Both tweens need to return a function which will be invoked for each frame of the animation, with a time value between 0 and 1, depending on the frame. The returned function must itself return a value, which is applied to the desired style or attribute every frame. In this thesis tweens are only specifically defined to animate svg path tags.


\subsubsection{Bar Chart}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
The bar-charts first defines two scales, the \texttt{xScale} as well as the \texttt{yScale}. The \texttt{xScale} is a linear scale to convert from a domain of the refugees [0, HighestNumberOfRefugeesInACountry] to a range of the available space [0, ourWidth]. This allows to find the appropriate x-coordinate for any number of refugees. It is used to draw each bar to its appropriate length. The \texttt{yScale} converts from any given country to a y position is done using a scale band. Therefor the domain is defined by providing an array of all possible countries and the range is [0, ourHeight]. This allows the proper height positioning of each bar using the resulting y-coordinate.

The bar-chart also makes use of axes. D3 has predefined functions to create axes from scales. An axis in D3 consists of many ticks. By default each tick has a label and a small line indicating its position. Furthermore there is a start and end line to indicate the whole domain. The bar-chart removes all the domain lines for styling reasons. The tick lines for the y-axis are also removed, as they are unnecessary here. The x-axis tick lines therefor are extended to cover the whole diagrams height. This is done to have a proper reference to read out the bars length.

\begin{minipage}{\linewidth}
    \begin{lstlisting}[style=htmlcssjs, captionpos=b, caption={The x axis implementation of the bar chart. The first constant defines the tick format. For each number there should be two significant digits. As the zero value is represented as "0.0" to match the previous rule of two significant digits, it is simply replaced by "0". The second constant defines the function creating the axis. The previous tick format is passed here. Furthermore the \texttt{tickSize} is set to the hight of the diagram. This way the initially small tick lines now cover the whole height of the diagram and allow for easier and more accurate readouts. Finally the \texttt{xAxisParentGroup} element, which is part of ther permantent hierarchical structure of the bar-chart, calls the \texttt{xAxis} function. This adds the Axis to the diagram. As a last step the domain lines are selected and removed for styling reasons.}, label={lst:bar-chart-axes}]
const xAxisTickFormat = number =>
    d3.format('.2s')(number)
        .replace('0.0', '0');

const xAxis = d3.axisBottom(xScale)
    .tickFormat(xAxisTickFormat)
    .tickSize(-ourHeight);

xAxisParentGroup.call(xAxis)
    .attr('transform', `translate(0,${ourHeight})`)
    .select('.domain')
        .remove();
    \end{lstlisting}
\end{minipage}

Each bar in the bar chart is composed of a \texttt{rect} for the bar itself and a \texttt{text} field as the label with the precise amount of refugees. Both these parts are children of one group element each. This group element has the \texttt{bar} class as attribute. Due to this structure, the bar-chart only requires a single data-join. The required selector matches all group elements with the \texttt{bar} class. In the enter sub-selection of the general update pattern, first a new group element with the \texttt{bar} class is added. Afterwards a \texttt{rect} as well as a \texttt{text} are added to the newly created group element.  The \texttt{rect} is filled with the appropriate color by calling the color scale. Both elements are positioned and sized accordingly using the previously defined scales. The x position of the text as well as the width of the rect are initialized as 0. These two values are immediately animated using a transition, to reach their actual values. This way new bars always build themselves up from the left side. The text field usually tries to stick to the inside right side of the rect. In case where there is not enough space available to the left, as the bar is shorter then the number to show, the text is placed to the right of the rect.

Elements in the update sub-selection are are resized in the width and text value if the number of refugees for this country changed. They might also be repositioned and resized in height, as new countries are added, or old ones removed from the data-set. All resizing is done using the transition for smooth animation of the changes. Elements in the exit selection are simply removed.

\subsubsection{Donut chart}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
As the donut-chart shows the total amount of refugees in the center, this value is computed first. This is achieved using the \texttt{d3.sum(data, d => d.refugees)} function. It creates the sum of all entries in the data, using the \texttt{refugees} field for each entry. After calculating this value, the appropriate text field is updated to contain the new number.

As each section of the donut-chart is made up of a path element, d3 provides two functions to generate pie and donut charts. The \texttt{d3.pie()} function calculates the appropriate start and end angle of each data-point. A padding angle has also been specified for some spacing between the sections of the diagram. The pie function returns a new object which holds a reference to our original data, additionally to the new sections information. 

The arc function is set up with an inner and an outer radius. Having an inner radius of zero generates a pie chart, whereas an inner radius greater than zero, like in this instance, creates a donut chart. The arc function which is set up here is later used in the general update pattern to generate SVG path objects from the pie pieces containing the start and end angles of each section.

As each section of the donut-chart is made up of a \texttt{path} element nested inside a group element, the selector for the data-join matches all group elements with the \texttt{arc} class. The data-join is then created using the previously created pie object. In the enter selection of the general update pattern, the parent group element is created first and provided with the \texttt{arc} class. Afterwards a path element is added. This path element is colored according to the color scale. Drawing the actual arc piece is done in an attribute tween. This animates the donut-chart to smoothly fill itself in the beginning. The implementation of this initial animation is almost same as the one seen in \ref{lst:donut-chart} for updating the arc sections. The only difference lies in the two \texttt{interpolate} functions using 0 as initial value instead of the respective \texttt{previousStartAngle} and \texttt{previousEndAngle}, as these two values are not assigned yet.

Lastly the path elements are registered to two callbacks, \texttt{mouseover} and \texttt{mouseout} using D3s \texttt{.on()} function. Both these events are used to show and update the appropriate text in the center of the donut chart. The effect which creates an outline around the currently hovered ovr path element is not linked to these events, but instead is achieved by CSS styling.

As the update behavior of the donut-chart consists only of updating the paths, it is fully described in listing \ref{lst:donut-chart}. The exit behavior removes appropriate sections.

\begin{minipage}{\linewidth}
    \begin{lstlisting}[style=htmlcssjs, captionpos=b, caption={The implementation of the arc update animations. There are two interpolate functions defined in the beginning. They are called \texttt{i} and \texttt{j}. Next the new values for start and end angle are stored on the node itself. This needs to be done to be able to reference these values again for the next update, as the previous angles will not be accessible through the pie object after regenerating it for an update. Finally the function which is called for each frame of the animation is defined and returned. This function first interpolates the start and end angle values using the previously defined functions and the time of time which has already pased in the animation. This time value is in the range of zero to one, depending on how far along the animation is. These newly interpolated angles define the start and end angle of the pie piece, which is then turned into a path element by calling the \texttt{arc} function for this pie piece.}, label={lst:donut-chart}]
.call(enter => enter.transition(t)
    .attrTween('d', (d, index, nodes) => {
        const i = d3.interpolate(nodes[index].previousStartAngle, d.startAngle);
        const j = d3.interpolate(nodes[index].previousEndAngle, d.endAngle);

        nodes[index].previousStartAngle = d.startAngle;
        nodes[index].previousEndAngle = d.endAngle;

        return time => {
            d.startAngle = i(time);
            d.endAngle = j(time);
            return arc(d);
        }
    })
)
    \end{lstlisting}
\end{minipage}


\subsubsection{Tree map}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
As the tree-map is intended to work with hierarchical data, it requires all data-points to have a link to their parent data-point. There is only one data-point without a link to a parent, which serves as a root element. As the refugees per country data-set is not in hierarchical structure, this is simulated first. Therefor a dummy object is added to the data array. Using the \texttt{d3.stratify()} command turns the data-set into a tree object by connecting each data-point to a parent, in this case the dummy object. The dummy element has no parent and serves as the root of the tree object. After removing the dummy element from the data again, the sum of refugees in the tree object is calculated. Using the \texttt{d3.treemap} command and providing it with information about the available space and padding between elements provides the trees leaves with their relevant size and position information.

The general update pattern adds a \texttt{rect} for each leaf of the tree object before styling it appropriately and animating its size and position. The \texttt{mouseover}, \texttt{mousemove} and \texttt{mouseout} events are registered for showing, updating and hiding the tooltips content and position, as the mouse hovers above a \texttt{rect} in the tree-map. the update selection smoothly moves and resizes the rects, while the exit selection removes them.


\subsubsection{Sankey graph}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
Both the donut-chart as well as the sankey-graph also define a constant called \texttt{totalRefugees}. This constant is created using the \texttt{d3.sum(data, d => d.refugees)} function. It creates the sum of all entries in the data, using the \texttt{refugees} field for each entry.

As the sankey-graph and tree-map are both intended to use with hierarchical data, some tricks are employed to simulate this. In both cases a new parent element is added and the appropriate links are created. In the resulting sankey-graph, this parent element can be seen on the left side as the Ukraine as origin for all refugees. Following this all the data dependent scales are defined.

\subsubsection{Circle graph}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}

\subsubsection{Area graph}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}


\section{Showcase}
%\textcolor{red}{
%How is the showcase structured? How can you get there? Why does it exist? Who might benefit? How can you reuse a part the interesting parts?}

To bring all the diagrams together, a showcase has been created. It  is split into two main parts. Firstly all the diagrams for refugees per country are covered. Secondly the diagrams for refugees over time are shown. As all diagrams in one section represent the same data-set, it allows for an easy visual comparison, as well as easier comparison of the code. When each diagram would show different data, it would be harder to distinguish between implementation differences which are due to the different representation and differences which are caused by accommodating different data-sets. Additionally each section has a table where the input data can be seen and modified.

\subsection{Integration of each diagram}
%\textcolor{red}{
%How is each diagram integrated? How can you access them? Where can you grab them standalone?}

Each diagram is implemented to work on its own and without the showcase. Each diagram is also designed to use all the space available in its container. When loading one of the diagrams HTMLs directly, it will therefore fill the whole browser window. The showcase loads each of the diagrams into a separate IFrame tag with a consistent aspect ratio.

\subsection{Data Updates}
%\textcolor{red}{
%How can you simulate data changes? Why is this useful?}

Each section of the showcase has a table which allows for data manipulation. Rows of data can be modified, added or removed here. The data changes here are not persistent and therefore do not get written in the original data csv files. When data is changed, the diagrams are provided with the updated data and adapt accordingly. For this thesis it is important to be able to modify the data, as one of the core features of D3 tested in this thesis is reacting to changes in data. This manual style of changing data is probably not so common in real world applications. Yet it is easy to replace these manual data changes to regular API calls or other automatically updating data-sources. As the source of the data changes does not matter for the functionality of D3, the manual approach chosen here is sufficient in demonstrating the possibilities of D3.
