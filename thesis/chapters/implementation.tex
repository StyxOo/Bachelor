\chapter{Implementation}
%\textcolor{red}{

%How are the chosen diagrams implemented? Which D3 modules have been used? How was the implementation done?}

In the following sections the process of creating the showcase and the diagrams are described. There are several parts to this. At first the data sets, which should be represented, are chosen. In most real world usages, this is already given. Afterwards the possible diagrams are considered and chosen. Their implementation and usages of D3 are described. Finally the showcase bringing all the diagrams together is described.

The implementation uses the currently latest version of D3, version 7.6.1. The JavaScript code uses exclusively arrow functions which have been introduced in ECMAScript6, the specification which JavaScript is build upon. The implementation has been tested using the following operating systems, browsers and versions:
\begin{enumerate}
    \item Windows 10:
    \begin{enumerate}
        \item Opera - version xxxxx
    \end{enumerate}
    \item Pop!\_OS 22.04 LTS:
    \begin{enumerate}
        \item Firefox - version 103.0 (64-bit)
    \end{enumerate}
\end{enumerate}

\section{Datasets}
%\textcolor{red}{
%What are our datasets about? Where do they come from?}
As different data-types allow for different representations and require varying parts of D3, the data used in this thesis has been specifically chosen to contain both types of categorical as well as numeric data. As there are no differences in the implementation of discrete and continuous data, no extra efforts was done to cover both these types.

All data used for the creation of the diagrams in this thesis originates from the UNHCR Ukraine refugee situation page\cite{unhcr}. The dataset about total cumulative border crossings from Ukraine per day\cite{unhcr_rpd} is in JSON format. The data about the border crossings into countries featured in the refugee response plan, as well as into other neighboring countries\cite{unhcr} were extracted directly as CSVs. While all data reference border crossings from Ukraine and not refugees directly, the UNHCR states that "[they do] not count border crossings of individuals from bordering countries leaving Ukraine to return home (i.e. Romanians returning to Romania), nonetheless among those forced to flee Ukraine are also Ukrainian nationals with dual citizenship"\cite{unhcr_note}. Therefore this thesis will henceforth use the refugee terminology.
The refugees per country cover a time-span between february 24th 2022 up until august 16th 2022\cite{unhcr}. The refugees per day cover the time from february 24th 2022 until july 17th 2022\cite{unhcr_rpd}.


%(Due to the currentness of the situation, the UNHCR only recently changed to using border crossings from Ukraine. Previously these were referred to as refugees fleeing Ukraine. As the implementation was already completed at this point and because it makes no difference to the workings of D3, this thesis will henceforth use the refugee wording again.)


To keep the implementations of the diagrams as simple as possible, some data preprocessing is done as the data is loaded, to make it align with the internal data structure. Therefore two data loader JavaScript files have been created. The first JavaScript file, the countryDataLoader.js reads both csv files containing information about the refugees fleeing into all neighboring countries. Both files are then combined to one data array containing an object, with properties for country and refugees, for each data entry. The second data loader, the dailyDataLoader.js, reads the JSON file containing information about the total refugees per day. As this JSON file contains a lot of filler data, which is not needed, the data loader strips all unnecessarily information away and produces a single array. This array contains an object, with properties for date and refugees, for each data entry. A section of the resulting data can be seen in table \ref{tab:data}. Both data loaders are accessed either by the respective data services which pass the data to the applicable diagrams, or by the diagrams directly. The data services, countryDataService.js and dailyDataService.js, are used by the showcase to fill the data tables in the showcase and pass along any data changes done here to the applicable diagrams.

\begin{table}
    \centering
    \begin{tabular}{l|r}
        Country & Refugees \\
        \hline \hline
        Poland & 5439431 \\
        Russian Federation & 2197679 \\
        ... & ... \\
        Belarus & 16689 \\
    \end{tabular}
    \quad
    \begin{tabular}{l|r}
        Date & Refugees \\
        \hline \hline
        Feb 24, 2022 & 79209 \\
        Feb 25, 2022 & 179525 \\
        ... & ... \\
        Jul 19, 2022 & 9567033 \\
    \end{tabular}
    \captionsetup{width=0.9\textwidth}
    \caption{A preview of the two data arrays after preprocessing. The left table contains the refugees per country. The right table shows the cumulative refugees per day. Each entry in the table corresponds to one object in the appropriate data array. Each object has two properties, according to the headers of the tables. The dates in the right table are JavaScript date objects. They are shortened here for readability.}
    \label{tab:data}
\end{table}


Together both resulting data sets contain most of the data types. The number of refugees, which can be found in both data sets, is a discrete attribute. The countries in one data set are a nominal attribute. The date in the other data set is a ordinal attribute instead.



%It would be possible to use both these data sets as is. Yet the vast amounts of filler data, which does not contain any valuable information, makes data accesses unnecessarily complicated and hard to follow along and understand the diagrams implementations. Therefore both data sets are preprocessed. In both cases the data sets are read and the valuable information extracted and saved in the CSV format. Both of the newly created CSV files have two columns and one header row. The resulting CSV of the refugees per country dataset, contains the two columns of country and refugees. The other resulting CSV contains a column for the date and one for the cumulative refugees. 

%(The data set about the refugees per country can also easily be converted into using percentages. After adding up the total amount of refugees from each data-point, one can convert the absolute number of refugees into percent.)

%\subsection{Data Types}
%\textcolor{red}{
%Which data types can be found in our data sets? Where?}

%The two chosen data sets already cover most of the data-types. Both dataset contain two attributes per data-point. The country is a categorical attribute. The number of refugees is discrete. When converting this data set into percentages, the percentage of refugees becomes a continuous attribute. In the refugees per date data set, the amount of refugees is still a discrete attribute. The date itself is an ordinal attribute though. As one day clearly comes before and after other days.

%Choosing data sets which cover all types of data-types was an important consideration. Different data-types can have different ways of representation, as well as different ways of implementation on the programming side of things.


\section{Diagrams}
%\textcolor{red}{
%describe all the diagrams and why they are special and what makes them tick. Why have they been chosen?}

The following section is about selecting and implementing each diagram. As there are countless ways to show the selected data sets, a selection of diagrams was made first. There are two mayor aspects taken into the account for selecting the diagrams. Primarily they should be realistically usable, as there is no point in creating unnecessarily complex visualizations. Secondly they should all require different aspects of the D3 library. This ensures that this thesis actually tests the possibilities of D3. To achieve this, four diagrams have been chosen to show the refugees per country data set. A bar chart, a donut-chart, a tree map and a Sankey diagram. For the data set showing the total amount of refugees over time, a circle graph and an area graph have been chosen.

The bar chart was chosen for implementation due to its simplicity and minimal amount of D3 functions needed. It provides a good starting point for learning D3, as well as being fairly common as a diagram. It was chosen over a column-chart, as the horizontal orientation of the bar chart allows the viewer to read the country name and the number of refugees in one line.
The main reason for choosing the donut-chart was its use of the specific D3 functions for creating pie and donut-charts. The donut was chosen for it's compact form while still allowing some additional information to be shown in the center. It is also used to present custom attribute tweens for animations.
The usage of D3s tree map functions was the main reason for choosing the tree map. Additionally it offers a good example for including CSS styling tricks, a tooltip and event-handling.
Both the tree map and Sankey diagram also provide an insight into working with other data-structures. The Sankey diagram was additionally chosen to present the usage of D3 packages.
The circle-chart was chosen to show more D3 scales, as well as the possibilities of using scales to create and animate custom legends.
Lastly, the area-chart uses more basic D3 functions for rendering lines and areas. These have not been used before, but can prove quite powerful when creating diagrams showing trends over time.

Whilst all diagrams are presented in one showcase, each diagrams is implemented to work standalone. This makes the comparison between diagrams, as well as evaluating the effort needed to create them easier. It also allows for easier adaptation if one were to use one of the diagrams as a template. Therefore all diagrams are implemented independently, using three parts: a HTML, a CSS and a JavaScript file. The HTML loads the D3 library in the header. The body of the HTML consists of a SVG tag where the diagram will be drawn, and a script tag which loads the JavaScript file. The CSS defines the general styling of the diagram which is not dependent on the input data. The main part of the implementation is done in the Javascript section. Additionally each diagram makes use of the respective data-service when used in the showcase. If the diagram is accessed directly, the diagram will get its data directly from the appropriate data loader.

The JavaScript file also follows a general pattern. At first there is a initialization section which is run once as the website is loaded. It is followed by a render function which is responsible for drawing and updating the diagram. Both are explained in the following subsections.

\subsection{Initialization}
Generally all things which are independent of the data are done during the initialization. It starts with setting some core variables. A reference to the SVG tag, which will be used as the container for the diagram, is made. It is followed by a margin definition for all four sides, where the margin of our diagram content in relation to the container size is defined. The resulting values for \verb|ourHeight| and \verb|ourWidth|, which are used as space to draw the diagram, are saved. 

Following there are a few group elements which are added to the SVG tag. Adding elements is achieved by calling \verb|.append('elementName')| on an existing element. In the first case, this is the previously stored reference to the SVG. As the \verb|append| command returns the newly created element, it can be directly stored in a variable for later reference, or provided with attributes via method chaining. Listing \ref{lst:hierarchy_creation} demonstrates how this works for the bar chart. The group elements added here provide a general hierarchy for different aspects of the diagram. Having a proper structure in place makes working with selections easier as well as helping with human readability of the SVGs content. As SVG elements are drawn on top of each other depending on their hierarchical order, this can also be used to mimic layers as they would be used in drawing applications. This general hierarchy is only created to a level which is independent of the provided data and differs depending on the type of diagram. For example the bar chart has separate groups for the axes and the content, see listing \ref{lst:hierarchy_result}, while the circle diagram has groups for the background legend and the content.

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={JavaScript code to create the hierarchy as used in the bar chart. The first line adds a new group element to the main SVG container using the \texttt{append} command. The newly added group element is saved in a constant for later references. Furthermore in line two an attribute is added to the new group element using the \texttt{attr} command and method chaining. It moves the group element from the left and top to allign with the margin definition. In each of the lines four, seven and ten, another group element is added. They are added to the previously created group element. They are all stored in constants for later reference and are provided with ID's for easier identification and debugging.}, label={lst:hierarchy_creation}]
const diagramGroup = SVG.append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

const xAxisParentGroup = diagramGroup.append('g')
    .attr('id', 'xAxis')

const yAxisParentGroup = diagramGroup.append('g')
    .attr('id', 'yAxis')

const contentParentGroup = diagramGroup.append('g')
    .attr('id', 'content')
\end{lstlisting}
\begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={The HTML structure which results from the JavaScript code in listing \ref{lst:hierarchy_creation}. The resulting tree structure clearly separates the different aspects of the diagram. Using a hierarchical approach makes not only later selections easier, but also increases human readability and simplifies debugging.}, label={lst:hierarchy_result}]
<SVG>
    <g transform=translate(118,20)>
        <g id="xAxis"></g>
        <g id="yAxis"></g>
        <g id="content"></g>
    </g>
</SVG>
    \end{lstlisting}
\end{minipage}


If there are data independent scales, they are defined here. A common example here is a color scale for nominal values. It is used in all diagrams showing the refugees per country. It is not important to already know the specific input values, to be able to create a list of colors which is used by the scale. When queried, it will return a new color from the list for each new query value. Therefore this scale does not require a predefined domain. Instead it is dynamically defined and extended with each new value querying the scale. It is important to note that when the predefined color list runs out of new colors, it starts reusing the same color list from the beginning.

Any general helper functions are also defined here. Both diagrams about the cumulative refugees per day make use of a date conversion function, which produces a nicely formatted date string from a JavaScript date object. The resulting strings are in the form of mmm-DD, for example Feb-07 or Jun-15.

\begin{minipage}{0.9\linewidth}
    \begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={Definition of the data independent color scale. \texttt{d3.schemeDarkv2} is a predefined list of color values which is to be used by the scale.}, label={color_scale}]
const colors = d3.scaleOrdinal(d3.schemeDark2);
    \end{lstlisting}
\end{minipage}

Finally if there are any static elements, they are also defined in the initialization. For example the tooltip used by the tree map or the center text fields in the donut-chart. Even though the data which these fields are supposed to show is not yet known, these fields are persistent and can therefore already be created here.

\subsection{Render}
Following the initialization section is the render function. The render function is called once in the beginning and every time the data set changes. The render function covers all data-dependent tasks, including the implementation of the data-joins and general update pattern. As the implementation of the render function greatly varies between the diagrams, all common features are described first. Afterwards the specifics for each diagram are described. If there are helper functions or constants required by the render function they are defined first. 

As all the diagrams make use of transitions for animations, a transition is defined with a duration of 1500 milliseconds. This transition is later called for each element which should be animated. Defining the transition here allows for all later calls to not only take the same amount of time without having to change the duration in more than one position, but also to reuse the same transition instance.

\subsubsection{Scales}
The data-dependent scales in this thesis are mostly used to calculate the coordinate position and sizing of elements in the diagrams. The bar chart for example defines two scales. A linear scale to find appropriate x-coordinates and a scale band for the y-coordinates of each bar. As these scales domains depend on the provided data, it is necessary that they are redefined with every render call.

\subsubsection{Data Joins}
After the scales are defined, the data joins are created. While some diagrams, like the bar chart, only use a single data-join, other diagrams, like the circle-diagram, make use of several data joins. Usually this is in accordance to how many independent parts the diagram consists of. The circle diagram uses one data join for the size legend in the background, one to update the circle showing the current data and one to update the text showing the current number of total refugees.

A data join is created when binding data to a selection. This is achieved by first calling the \verb|.data(DATA)| function of a selection. The data function creates pairs of elements and data entries. By default, these are matched through their index in the selection and data arrays. This can lead to unexpected behavior when entries are removed or inserted at the not last position. Therefore the default identifier function can be overwritten by passing a custom identifier function as the second optional parameter to the data function. A custom identifier function should return a value and is called for each element in the data array. For the refugees per country data set in this thesis, the identifier is usually \verb|d => {return d.country}|.

When a data join is initially created, or when data-points are added, there is not a sufficient amount elements in the selection to pair them with data entries. D3 will therefore create empty placeholders for these elements. To make these placeholders become a part of the DOM, the \verb|.join()| function is added after the \texttt{data()} call. There are two ways to use the join function. One can either pass a string which will result in adding a matching tag to the DOM, or define functions for the general update pattern. When using the simple string method, the attributes and style for each new element can then be defined by method chaining. This approach is reasonable for diagrams that do not need to react to data changes. As all diagrams in this thesis implement the full extent of the general update pattern to be able to react to changing data and use the full possibilities of D3, the second approach is used.

\subsubsection{General Update Pattern}
%\textcolor{red}{
%How is this implemented? Where does it come into play?}

When the join function is called, instead of passing a single string as parameter, three functions can be passed as parameters. These three functions correspond to the three cases of the general update pattern and describe their respective behavior. Each of the three functions has one input parameter, corresponding to the respective sub-selection. In the enter function usually an element is added to the DOM. In the exit function elements are removed. This is the default behavior and can be omitted. The update function is optional, but always used in this thesis, as this is the place to update existing elements to accommodate for data changes and therefore possibly removed or newly added elements as well. All three functions run on all the elements of the appropriate sub-selection.

The enter function should add the applicable placeholder element to the SVG as actual content. Therefore the first part of the enter function is usually an \texttt{.append(string)} call. The string describes the tag which will be added to the DOM. Afterwards the applicable styles, attributes and sub-elements are added. This can be achieved with the \texttt{.attr("attributeName", "value")}. While styles can be added with the \texttt{.style("property", "value")} function, the same can be achieved more cleanly by predefining styles in the CSS and adding applicable classes to the element. The selector used to define the current data-join, should be able to match the newly created as well. Therefore enough attributes need to be provided. This is important when the selection is recreated when updating the diagram. When positioning a new or existing element the scales are used to compute the applicable coordinate space.

The update function is necessary when the diagram should be able to react to data changes. It is usually similar to the enter function, in that it adjusts the positioning and sizing of the elements according to the possibly changes scales. 

The exit function is defined by default to simply remove the applicable elements.

All three functions can make use of animations and transitions to improve their feel. The diagrams created for this thesis only animate the enter and update behavior. Why animations are useful and how they are implemented is described in the following section.

\subsubsection{Animations}
%\textcolor{red}{
%What are they? How do they work? Why are there two kinds? What makes them tick?}

Animations can improve the feel, appeal and readability of diagrams. When a diagram is updated due to data changes, it is easier to understand and see the changes when for example bars in a bar chart shift to their new positions, instead of a seemingly entirely different diagram popping up. The animations allow the viewer to keep track of the existing entries and visually follow any changes. For example the growth or shrinking of the length of a bar in a bar chart. Animations can also be used when initially drawing the diagram, to guide viewer attention.

Animating elements in D3 is achieved by using transitions. Transitions are called from a selection and run on all the elements of the selection. A transition requires a duration and can also be provided with a delay and an easing function. The duration and delay are both in milliseconds. Animating numerical or color values is very easy with transitions. It is only required to call the attribute or style with the target value and the transition function will calculate and show interpolated frames. This makes it very fast and easy to animate for example positioning or sizing of elements.

Instead of using the default behaviors for numbers, string and colors or when trying to animate other values like SVG paths, a tween function can be defined using \verb|attrTween| or \verb|styleTween|. Both tweens need to return a function which will be invoked for each frame of the animation, with a time value between 0 and 1, depending on the frame. The returned function must itself return a value, which is applied to the desired style or attribute every frame. In this thesis tweens are only specifically defined to animate SVG path tags.


\subsubsection{Bar Chart}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
The bar chart, as well as the following implementations of the donut chart, the tree map and the Sankey graph all make use of the dataset containing the number of refugees per country they fled to.

The bar charts first defines two scales, the \texttt{xScale} as well as the \texttt{yScale} (see \ref{app:bar-chart} lines 42ff). The \texttt{xScale} is a linear scale to convert from a domain of the refugees [0, HighestNumberOfRefugeesInAnyCountry] to a range of the available space [0, ourWidth]. This allows to find the appropriate x-coordinate for any number of refugees. It is used to draw each bar to its appropriate length. The \texttt{yScale} converts from any given country to a y position is done using a scale band. Therefore the domain is defined by providing an array of all possible countries and the range is [0, ourHeight]. This allows the proper height positioning of each bar using the resulting y-coordinate.

The bar chart also makes use of axes. The y-axis shows the countries, while the x-axis shows the amount of refugees. D3 has predefined functions to create axes from scales. An axis in D3 consists of many ticks. By default each tick has a label and a small line indicating its position. Furthermore there is a start and end line to indicate the whole domain. The bar chart removes all the domain lines for styling reasons. The tick lines for the y-axis are also removed, as they are unnecessary here. The x-axis tick lines therefore are extended to cover the whole diagrams height. This is done to have a proper reference to read out the bars length.

\begin{minipage}{0.9\linewidth}
    \begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={The x axis implementation of the bar chart. The first constant defines the tick format. For each number there should be two significant digits. As the zero value is represented as "0.0" to match the previous rule of two significant digits, it is simply replaced by "0". The second constant defines the function creating the axis. The previous tick format is passed here. Furthermore the \texttt{tickSize} is set to the hight of the diagram. This way the initially small tick lines now cover the whole height of the diagram and allow for easier and more accurate readouts. Finally the \texttt{xAxisParentGroup} element, which is part of ther permantent hierarchical structure of the bar chart, calls the \texttt{xAxis} function. This adds the Axis to the diagram. As a last step the domain lines are selected and removed for styling reasons. (Section from \ref{app:bar-chart} lines 60ff)}, label={lst:bar-chart-axes}]
const xAxisTickFormat = number =>
    d3.format('.2s')(number)
        .replace('0.0', '0');

const xAxis = d3.axisBottom(xScale)
    .tickFormat(xAxisTickFormat)
    .tickSize(-ourHeight);

xAxisParentGroup.call(xAxis)
    .attr('transform', `translate(0,${ourHeight})`)
    .select('.domain')
        .remove();
    \end{lstlisting}
\end{minipage}

Each bar in the bar chart is composed of a \texttt{rect} for the bar itself and a \texttt{text} field as the label with the precise amount of refugees. The \texttt{rect} and \texttt{text} are both children of one group element with the \texttt{bar} class as attribute. Due to this structure, the bar chart only requires a single data-join. The required selector matches all group elements with the \texttt{bar} class. In the enter sub-selection of the general update pattern, first a new group element with the \texttt{bar} class is added. Afterwards a \texttt{rect} as well as a \texttt{text} are added to the newly created group element. The \texttt{rect} is filled with the appropriate color by calling the color scale. Both elements are positioned and sized accordingly using the previously defined scales. The x position of the text as well as the width of the rect are initialized as 0. These two values are immediately animated using a transition, to reach their actual values. This way new bars always build themselves up from the left side. The text field usually tries to stick to the inside right side of the rect. In case where there is not enough space available to the left, as the bar is shorter than the number to show, the text is placed to the right of the rect.

Elements in the update sub-selection are resized in the width and text value if the number of refugees for this country changed. They might also be repositioned and resized in height, as new countries are added, or old ones removed from the data set. All resizing is done using the transition for smooth animation of the changes. Elements in the exit selection are simply removed.

\subsubsection{Donut chart}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}

As the donut-chart shows the total amount of refugees in the center, this value is computed first. This is achieved using the \texttt{d3.sum(data, d => d.refugees)} function (see \ref{app:donut-chart} line 82). It creates the sum of all entries in the data, using the \texttt{refugees} field for each entry. After calculating this value, the appropriate text field is updated to contain the new number.

As each section of the donut-chart is made up of a path element, D3 provides two functions to generate pie and donut charts. The \texttt{d3.pie()} function calculates the appropriate start and end angle of each data-point (see \ref{app:donut-chart} lines 90ff). A padding angle has also been specified for some spacing between the sections of the diagram. The \texttt{d3.pie()} function returns a new object which holds a reference to our original data, additionally to the new sections information (see \ref{app:donut-chart} lines 96ff). 

The arc function is set up with an inner and an outer radius. Having an inner radius of zero generates a pie chart, whereas an inner radius greater than zero, like in this instance, creates a donut chart. The arc function which is set up here is later used in the general update pattern to generate SVG path objects from the pie pieces containing the start and end angles of each section.

As each section of the donut-chart is made up of a \texttt{path} element nested inside a group element, the selector for the data-join matches all group elements with the \texttt{arc} class. The data-join is then created using the previously created pie object. In the enter selection of the general update pattern, the parent group element is created first and provided with the \texttt{arc} class. Afterwards a path element is added. This path element is colored according to the color scale. Drawing the actual arc piece is done in an attribute tween. This animates the donut-chart to smoothly fill itself in the beginning. The implementation of this initial animation is almost same as the one seen in \ref{lst:donut-chart} for updating the arc sections. The only difference lies in the two \texttt{interpolate} functions using 0 as initial value instead of the respective \texttt{previousStartAngle} and \texttt{previousEndAngle}, as these two values are not assigned yet.

Lastly the path elements are registered to two callbacks, \texttt{mouseover} and \texttt{mouseout} using D3s \texttt{.on()} function (see \ref{app:donut-chart} lines 123 and 129). Both these events are used to show and update the appropriate text in the center of the donut chart. The effect which creates an outline around the currently hovered over path element is not linked to these events, but instead is achieved by CSS styling.

As the update behavior of the donut-chart consists only of updating the paths, it is fully described in listing \ref{lst:donut-chart}. The exit behavior removes appropriate sections.

\begin{minipage}{0.9\linewidth}
    \begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={The implementation of the arc update animations. There are two interpolate functions defined in the beginning. They are called \texttt{i} and \texttt{j}. Next the new values for start and end angle are stored on the node itself. This needs to be done to be able to reference these values again for the next update, as the previous angles will not be accessible through the pie object after regenerating it for an update. Finally the function which is called for each frame of the animation is defined and returned. This function first interpolates the start and end angle values using the previously defined functions and the time of time which has already pased in the animation. This time value is in the range of zero to one, depending on how far along the animation is. These newly interpolated angles define the start and end angle of the pie piece, which is then turned into a path element by calling the \texttt{arc} function for this pie piece. (Section from \ref{app:donut-chart} lines 136ff)}, label={lst:donut-chart}]
.call(enter => enter.transition(t)
    .attrTween('d', (section, index, nodes) => {
        const interpolateStartAngle = d3.interpolate(nodes[index].previousStartAngle, section.startAngle);
        const interpolateEndAngle = d3.interpolate(nodes[index].previousEndAngle, section.endAngle);

        nodes[index].previousStartAngle = section.startAngle;
        nodes[index].previousEndAngle = section.endAngle;

        return time => {
            section.startAngle = interpolateStartAngle(time);
            section.endAngle = interpolateEndAngle(time);
            return arc(section);
        }
    })
)
    \end{lstlisting}
\end{minipage}


\subsubsection{Tree map}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
As the tree map is intended to work with hierarchical data, it requires all data-points to have a link to their parent data-point. There is only one data-point without a link to a parent, which serves as the root element. As the refugees per country data set is not in hierarchical structure, this is simulated first. Therefore a dummy object is added to the data array. Using the \texttt{d3.stratify()} command turns the data set into a tree object by connecting each data-point to a parent, in this case the dummy object (see \ref{app:tree-map} line 70). The dummy element has no parent and serves as the root of the tree object. After removing the dummy element from the data again, the sum of refugees in the tree object is calculated. Using the \texttt{d3.treemap} command and providing it with information about the available space and padding between elements provides the trees leaves with their relevant size and position information (see \ref{app:tree-map} line 85).

The general update pattern adds a \texttt{rect} for each leaf of the tree object before styling it appropriately and animating its size and position. The \texttt{mouseover}, \texttt{mousemove} and \texttt{mouseout} events are registered for showing, updating and hiding the tooltips content and position, as the mouse hovers above a \texttt{rect} in the tree map. the update selection smoothly moves and resizes the rects, while the exit selection removes them.


\subsubsection{Sankey diagram}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
The Sankey diagram consists of nodes and links. Therefore these two arrays are constructed first. Each node represents one country. The links describe the flow of values, in this case refugees, between nodes. This is achieved by providing a source, a target and the value. To be able to show a flow from the Ukraine to the other countries, the Ukraine is added as a node. All countries from our data are added as nodes, as well as a link to the Ukraine node is created. The resulting arrays are provided to the \texttt{d3.Sankey()} function (see \ref{app:sankey} line 48). This function is not part of the default D3 namespace. Instead it is added by additionally importing the Sankey package in the Sankeys HTML page. The \texttt{d3.Sankey()} function adds additional information to the nodes and links allowing for appropriate placement of the according elements. It also adds all the links' values to create a source value for the Ukraine node.

The Sankey diagram makes use of two data-joins. The first one links the nodes to appropriate group elements. During the enter behavior, each group elements is filled with a \texttt{rect} and a \texttt{text} element. The \texttt{rect} represents a node in the Sankey diagram and is sized according to the number of refugees and styled according to the country using the color scale. To make the color scale consistent with the other diagrams, the Ukraine node is provided with a fixed color. this prevents the Ukraine node from querying the color scale and creating inconsistency with the other diagrams which do not contain a representation for the Ukraine. The \texttt{text} label contains the name and amount of refugees per country. It is placed next to the appropriate \texttt{rect}s. This can be on the left or rights side, depending on the x position of the rects. If the rect is in the left half of the diagram the label is right, if the rect is in the right half the label is left. Both rect and text make use of transitions to smoothly build up the diagram. The text also makes use of a small delay to the transition by using the \texttt{.delay(100)} function (see \ref{app:sankey} line 93).

The second data-join takes care of the links. They are matched to path elements. Each path is styled to match with the country it leads to. The required SVG path is created using the \texttt{d3.SankeyLinkHorizontal()} command (see \ref{app:sankey} line 111). As the resulting path is only a single line, the stroke-width attribute corresponds to the size of the link. The links are also animated using the transition. When initially appearing, the links are provided with a delay before fading into existence after the nodes have settled in their positions.

\subsubsection{Circle graph}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}
The circle graph, as well as the area graph described in the following section, both make use of the data set about the cumulative refugees per day.

The circle graph makes use of two data dependent scales. A time scale is created using \texttt{d3.scaleQuantize()} (see \ref{app:circle-graph} line 55). It is used for converting the time slider value to an actual date. As the time slider value provides a value between zero and one, this domain is mapped to the range of available dates in the data set. The second scale is used to get the correct radius of the circle. Because the area of the circle corresponds to the number of refugees, it is important to not scale the radius linearly. This would lead to circle areas which do not represent the correct number of refugees. Scaling the radius linearly would introduce a lie-factor higher than one. In fact, due to the relation between a linear change in radius and a change which keeps the area consistent, the lie factor increases, the higher the amount of refugees is. To avoid this, a \texttt{d3.scaleSqrt()} is used (see \ref{app:circle-graph} line 60). The domain is set to [0, HighestNumberOfTotalRefugees] and the range to [0, ourHeight/2]. This scale is also used for drawing the background legend. This is achieved by getting the ticks of the scale and saving the appropriate values in an array. This array is rendered in circles using the first data-join. This data-join draws and updates a circle and a text label for each tick.

As the actual content of the diagram does not draw one mark per data-point, as the refugee number for only one data entry is shown at a time. The time scale is used to determine which is the currently selected date from the time value which is provided by the slider in the range of zero to one. The resulting date is used to get the corresponding data for that date from the data set. This allows the diagram to reuses only use one circle and one text label in its representation. Therefore the second data-join also looks a bit different. Instead of linking actual data, an array with an arbitrary single entry is linked to the selection. Without this single element, D3 would not draw the circle, as it assumes that there is no data to show. The identifier function also always returns the same value, no matter what data was linked. This makes sure that the same circle element is matched by the selector on each render call, as to not draw a new circle every time the diagram is supposed to update. The circle and text are both created and styled using the data which was found for the current date.

\subsubsection{Area graph}
%\textcolor{red}{
%How does it work? Which d3 features does it use? how do they work?}

The area graph makes use of the same time scale as the circle graph. Additionally it uses a linear scale for the y-axis and a scale band for the x-axis. The y-axis represents the number of refugees, while the x-axis shows the days. Both axes are added to the diagram in the same way as is done in the bar chart. As showing all days on the x-axis would be too dense, the values are filtered and only 15 equidistant days are shown. This is achieved by using JavaScript \texttt{filter} function for arrays and specifying a custom filter which is to be evaluated for each entry in the domain of the x-axis scale band.

The main content of the area graph consists of two parts. One part shows the area, while the other one is the date-line showing the current date. The area and the line following along the top of the area, the top-line, are two separate path elements. Their definition can be seen in listing \ref{lst:line-area}. Because the area and line both cover the whole range of data at once, the data-join, which creates and updates them, uses the same single element dummy data as the circle graph. When creating or updating the line and area, the whole dataset is passed to the respective functions.

\begin{minipage}{0.9\linewidth}
    \begin{lstlisting}[style=htmlCSSjs, captionpos=b, caption={The first constant defines the function for creating the top-line of the area graph. This is achieved by specifying functions for x and y values. D3 uses them to calculate the position of each point on the line. Using the arrow functions here, applies this for each entry of the data set which is passed as a parameter when calling this function. When the function is called and a data set is provided, by calling \texttt{line(data)}, the line is constructed by calculating the according x and y positions for every data-point. Defining and creating the area works in similar fashion. Yet there are two y-positions for each x-position. This allows for a huge variety of shapes. Yet it is not possible to create concave ends on the right or left side of the shape, assuming left and rigth are oriented horizontally. Of course the created shape can be rotated and oriented using all possible SVG tags and attributes. (Section from \ref{app:area-graph} lines 111ff)}, label={lst:line-area}]
const line = d3.line()
    .x(d => xScaleWithOffset(d.date))
    .y(d => yScale(d.refugees));

const area = d3.area()
    .x(d => xScaleWithOffset(d.date))
    .y1(ourHeight)
    .y0(d => yScale(d.refugees));
    \end{lstlisting}
\end{minipage}

The date-line is made up of three elements. A circle element rides on the top line of the area, a vertical line to indicate the current day on the x-axis and a text label to show the days refugee value. All three parts are simply created and updated in the second data-join. This data-join makes use of the same kind of dummy data as seen in the previous data-join and the circle graph.


\section{Showcase}
%\textcolor{red}{
%How is the showcase structured? How can you get there? Why does it exist? Who might benefit? How can you reuse a part the interesting parts?}

To bring all the diagrams together, a showcase has been created. It  is split into two main parts. Firstly all the diagrams showing the  refugees per country they fled to, are covered. Secondly the diagrams for refugees over time are shown. As all diagrams in one section represent the same data set, it allows for an easy visual comparison, as well as easier comparison of the code.

Each diagram is implemented to work on its own and without the showcase. Each diagram is also designed to use all the space available in its containing SVG element. When loading one of the diagrams HTMLs directly, it will therefore fill the whole browser window. The showcase uses this functionality and loads each of the diagrams into a separate IFrame tag with a consistent aspect ratio. When a diagram is loaded in the showcase, it also registers with the applicable data service. This allows the data service to update the diagram as the data is changed, as is described in the following section.

\subsection{Data Updates}
%\textcolor{red}{
%How can you simulate data changes? Why is this useful?}

Each section of the showcase has a table which allows for data manipulation. Rows of data can be modified, added or removed here. The data changes here are not persistent and therefore do not get saved in the original data files. While the correctness of the initial data is not guaranteed, changing the data entries obviously falsifies the resulting diagrams. Changes in the data are registered by the respective data service. It created a new data set from the data in the table when updating. This new data set is passed long as a parameter to all the applicable diagrams when calling their render function to update.

For this thesis it is important to be able to modify the data, as one of the core features of D3 tested in this thesis is reacting to changes in data. This manual style of modifying data is probably not so common in real world applications. Yet it is easy to replace these manual data changes to regular API calls or other automatically updating data-sources. As the source of the data changes does not matter for the functionality of D3, the manual approach chosen here is sufficient in demonstrating the possibilities of D3.
